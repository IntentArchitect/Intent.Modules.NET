<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>46410048-55e6-4cc9-8ee0-dcd0e24a8ee2</id>
  <name>MediatR CRUD Extensions</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions />
  <elementSettings />
  <elementExtensions>
    <elementExtension type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9">
      <mappingSettings />
      <macros>
        <macro trigger="on-mapped">
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    if (primaryKeys.length == 0) {
        // Implicit key:
        primaryKeys.push({
            id: null,
            name: "Id",
            typeId: getSurrogateKeyType(),
            mapPath: null,
            isNullable: false,
            isCollection: false
        });
    }
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x) &amp;&amp; DomainHelper.hasPrimaryKey(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "942eae46-49f1-450e-9274-a92d40ac35fa"; //"01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        var _a;
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                field.typeReference.setType(key.typeId);
                if (((_a = key.mapPath) !== null &amp;&amp; _a !== void 0 ? _a : []).length &gt; 0) {
                    field.setMapping(key.mapPath);
                }
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
    static formatName(str, type) {
        switch (type) {
            case "property":
            case "class":
                return toPascalCase(str);
            case "parameter":
                return toCamelCase(str);
            default:
                return str;
        }
    }
}
class ElementManager {
    constructor(command, settings) {
        var _a;
        this.command = command;
        this.settings = settings;
        this.mappedElement = (_a = command.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, type) {
        var _a;
        let field = createElement(this.settings.childSpecialization, ServicesHelper.formatName(name, (_a = this.settings.childType) !== null &amp;&amp; _a !== void 0 ? _a : "property"), this.command.id);
        const typeReferenceDetails = type == null
            ? null
            : typeof (type) === "string"
                ? { id: type, isNullable: false, isCollection: false }
                : { id: type.typeId, isNullable: type.isNullable, isCollection: type.isCollection };
        if (typeReferenceDetails != null) {
            field.typeReference.setType(typeReferenceDetails.id);
            field.typeReference.setIsCollection(typeReferenceDetails.isCollection);
            field.typeReference.setIsNullable(typeReferenceDetails.isNullable);
        }
        return field;
    }
    addChildrenFrom(elements, options) {
        let order = 0;
        elements.forEach(e =&gt; {
            if (e.mapPath != null) {
                if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                    return;
                }
            }
            else if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; x.getName().toLowerCase() === e.name.toLowerCase())) {
                return;
            }
            let field = this.addChild(e.name, e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (options === null || options === void 0 ? void 0 : options.addToTop) {
                field.setOrder(order++);
            }
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(param1, mappingSettingsId) {
        let elementIds;
        let element;
        if (Array.isArray(param1)) {
            elementIds = param1;
            element = lookup(elementIds[elementIds.length - 1]);
        }
        else {
            elementIds = [param1.id];
            element = param1;
        }
        this.mappedElement = element;
        this.command.setMapping(elementIds, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
/**
 * Workaround for element's from referenced packages not having getParent()
 * @param element The element whose parent should be searched for
 * @param parentSpecializationType The specialization type of the parent
 */
function getParent(element, parentSpecializationType) {
    const elements = lookupTypesOf(parentSpecializationType);
    const parent = elements
        .find(x =&gt; x.getChildren(element.specialization)
        .some(child =&gt; child.id === element.id));
    if (parent == null) {
        throw new Error("Could not find parent");
    }
    return parent;
}
/// &lt;reference path="../common/domainHelper.ts" /&gt;
/// &lt;reference path="../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/getParent.ts" /&gt;
/**
 * Gets select details of a mapped Command/Query. Intended for centralized logic of working out
 * things like keys for both the entity and owning entity if applicable.
 *
 * If the Command is for entity creation (either due to being mapped to a constructor or being
 * prefixed with "Create"), then primary keys for the entity are not populated.
 * @param request The Command or Query that has been mapped
 */
function getMappedRequestDetails(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    // Advanced mapping:
    if (mappedElement == null) {
        const advancedMappings = request.getAssociations()
            .filter(x =&gt; x.hasMappings(queryEntityMappingTypeId) ||
            x.hasMappings(createEntityMappingTypeId))
            .map(x =&gt; x.getMapping(queryEntityMappingTypeId) ||
            x.getMapping(createEntityMappingTypeId));
        if (advancedMappings.length === 1) {
            mappedElement = advancedMappings[0].getTargetElement();
        }
    }
    if (mappedElement == null) {
        return null;
    }
    let entity = mappedElement;
    if (entity.specialization !== "Class") {
        entity = getParent(entity, "Class");
    }
    const result = {
        entity: entity,
        mappingTargetType: mappedElement.specialization,
        entityKeyFields: [],
        ownerKeyFields: []
    };
    result.owningEntity = DomainHelper.getOwningAggregate(entity);
    // As long as it's not for creation, populate the PKs of the entity:
    if (result.mappingTargetType !== "Class Constructor" &amp;&amp;
        !request.getName().toLowerCase().startsWith("Create")) {
        result.entityKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity)
            : getKeysForOperationMapping(request, entity);
    }
    // If the entity is owned, populate its fields:
    if (result.owningEntity != null) {
        result.ownerKeyFields = result.mappingTargetType === "Class"
            ? getKeysForClassMapping(request, entity, result.owningEntity)
            : getKeysForOperationMapping(request, entity, result.owningEntity);
    }
    return result;
    /**
     * Return field details for primary keys. As requests mapped to operations and constructors can
     * never possibly map the attributes, these fields can only ever be matched by name.
     * @param request The CQRS Command or Query entity
     * @param owningEntity The Owning Aggregate Class
     */
    function getKeysForOperationMapping(request, entity, owningEntity) {
        const pks = DomainHelper.getPrimaryKeys(owningEntity !== null &amp;&amp; owningEntity !== void 0 ? owningEntity : entity);
        return pks.map(pk =&gt; {
            let fieldName = toPascalCase(pk.name);
            if (owningEntity != null) {
                fieldName = removePrefix(fieldName, toPascalCase(owningEntity.getName()));
                fieldName = `${owningEntity.getName()}${toCamelCase(fieldName)}`;
            }
            fieldName = ServicesHelper.getFieldFormat(fieldName);
            const existingField = request.getChildren("DTO-Field").find(field =&gt; field.getName().toLowerCase() == fieldName.toLowerCase());
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: [],
                name: fieldName,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
    function getKeysForClassMapping(request, entity, owningEntity) {
        const keys = owningEntity != null
            ? DomainHelper.getForeignKeys(entity, owningEntity)
            : DomainHelper.getPrimaryKeys(entity);
        return keys.map(pk =&gt; {
            const existingField = request.getChildren("DTO-Field").find(field =&gt; {
                if (field.getMapping() != null) {
                    return field.getMapping().getPath().some(x =&gt; x.id == pk.id);
                }
                return (pk.name.toLowerCase() === field.getName().toLowerCase());
            });
            return {
                existingId: existingField === null || existingField === void 0 ? void 0 : existingField.id,
                mappingPath: pk.mapPath,
                name: pk.name,
                typeId: pk.typeId,
                isCollection: pk.isCollection,
                isNullable: pk.isNullable
            };
        });
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/**
 * Ensures that for the provided contract, it has the provided field creating it if necessary and
 * then ensure the field has the correct typeReference details and order.
 * The field's element is returned.
 */
function ensureHasField(options) {
    const { contract, fieldDetail, mappingSettingsId, order } = options;
    let field = fieldDetail.existingId != null
        ? contract.getChildren("DTO-Field").find(x =&gt; x.id === fieldDetail.existingId)
        : createElement("DTO-Field", fieldDetail.name, contract.id);
    field.typeReference.setType(fieldDetail.typeId);
    field.typeReference.setIsCollection(fieldDetail.isCollection);
    field.typeReference.setIsNullable(fieldDetail.isNullable);
    if (order != null) {
        field.setOrder(order);
    }
    if (mappingSettingsId != null) {
        field.setMapping(fieldDetail.mappingPath, mappingSettingsId);
    }
    return field;
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../../common/getMappedRequestDetails.ts" /&gt;
/// &lt;reference path="ensureHasField.ts" /&gt;
function onMapCommand(element, isForCrudScript, isForCreate = false) {
    var _a, _b, _c;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    // const mapToDomainDataSettingsId = "735c87d0-06fc-4491-8b5f-5adc6f953c54";
    const mappingDetails = getMappedRequestDetails(element);
    if (mappingDetails == null) {
        return;
    }
    if (isForCrudScript ||
        mappingDetails.mappingTargetType !== "Class") {
        let order = 0;
        let keyFields = mappingDetails.ownerKeyFields;
        if (!isForCreate) {
            keyFields = keyFields.concat(mappingDetails.entityKeyFields);
        }
        for (const keyField of keyFields) {
            ensureHasField({
                contract: element,
                fieldDetail: keyField,
                order: order++
            });
        }
    }
    if (mappingDetails.mappingTargetType === "Operation" &amp;&amp;
        isComplexType((_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType())) {
        getOrCreateCommandCrudDto(element, element, false, mapFromDomainMappingSettingId);
    }
    const fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; ((_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement().specialization.startsWith("Association")); });
    fields.forEach(field =&gt; {
        getOrCreateCommandCrudDto(element, field, true, projectMappingSettingId);
    });
    const complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp;
            isComplexType((_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType());
    });
    complexFields.forEach(cf =&gt; {
        getOrCreateCommandCrudDto(element, cf, false, projectMappingSettingId);
    });
    function isComplexType(element) {
        if (element == null) {
            console.warn("isComplexType element parameter received null");
        }
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object";
    }
    function getOrCreateCommandCrudDto(command, dtoField, autoAddPrimaryKey, mappingTypeSettingId) {
        let mappedElement = dtoField.getMapping().getElement();
        if (mappedElement.typeReference == null)
            throw new Error("TypeReference is undefined");
        let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
        let domainName = mappedElement.typeReference.getType().getName();
        let baseName = command.getMetadata("baseName")
            ? `${command.getMetadata("baseName")}${domainName}`
            : domainName;
        let dtoName = `${originalVerb}${baseName}`;
        let dto = getOrCreateDto(dtoName, command.getParent());
        dto.setMetadata("originalVerb", originalVerb);
        dto.setMetadata("baseName", baseName);
        dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
        ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
        dtoField.typeReference.setType(dto.id);
    }
}
/// &lt;reference path="../_common/onMapCommand.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Application.MediatR.CRUD
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/command-on-map/command-on-map.ts
 */
onMapCommand(element, false);
</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="DTO-Field" typeId="7baed1fd-469b-4980-8fd9-4cefb8331eb2">
      <mappingSettings />
      <macros>
        <macro trigger="on-created">
          <script>if (element.getName()) {
    element.setName(toPascalCase(element.getName()));
}</script>
        </macro>
        <macro trigger="on-name-changed">
          <script>if (element.getName()) {
    element.setName(toPascalCase(element.getName()));
}</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0">
      <mappingSettings />
      <macros>
        <macro trigger="on-mapped">
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getSurrogateKeyType.ts" /&gt;
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
        default:
            return str;
    }
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        addPrimaryKeys(dto, domainElement, true);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.getName().toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
function addPrimaryKeys(dto, entity, map) {
    const primaryKeys = getPrimaryKeysWithMapPath(entity);
    if (primaryKeys.length == 0) {
        // Implicit key:
        primaryKeys.push({
            id: null,
            name: "Id",
            typeId: getSurrogateKeyType(),
            mapPath: null,
            isNullable: false,
            isCollection: false
        });
    }
    for (const primaryKey of primaryKeys) {
        const name = getDomainAttributeNameFormat(primaryKey.name);
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName().toLowerCase() == name.toLowerCase())) {
            continue;
        }
        const dtoField = createElement("DTO-Field", getFieldFormat(name), dto.id);
        dtoField.typeReference.setType(primaryKey.typeId);
        if (map &amp;&amp; primaryKey.mapPath != null) {
            console.log(`Doing mapping for ${dtoField.id}`);
            dtoField.setMapping(primaryKey.mapPath);
        }
    }
}
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return Object.values(keydict);
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
}
/// &lt;reference path="./onMapFunctions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a; return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO" &amp;&amp; x.isMapped() &amp;&amp; x.getMapping().getElement().specialization.startsWith("Association"); });
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d, _e;
        return ((_a = x.typeReference.getType()) === null || _a === void 0 ? void 0 : _a.specialization) != "DTO"
            &amp;&amp; (complexTypes.includes((_e = (_d = (_c = (_b = x.getMapping()) === null || _b === void 0 ? void 0 : _b.getElement()) === null || _c === void 0 ? void 0 : _c.typeReference) === null || _d === void 0 ? void 0 : _d.getType()) === null || _e === void 0 ? void 0 : _e.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
/// &lt;reference path="../_common/onMapQuery.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Application.MediatR.CRUD
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/services-cqrs-crud/query-on-map/query-on-map.ts
 */
onMapQuery(element);
</script>
        </macro>
      </macros>
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions />
  <mappingSettings />
  <mappableElementPackages />
  <mappableElementPackageExtensions />
</settings>