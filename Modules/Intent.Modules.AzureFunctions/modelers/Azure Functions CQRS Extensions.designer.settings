<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>02f89497-6ed1-4926-9b80-9f2700455d00</id>
  <name>Azure Functions CQRS Extensions</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions />
  <elementSettings />
  <elementExtensions>
    <elementExtension type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9">
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Expose as Azure Function</text>
          <shortcut>ctrl + shift + z</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <script>let azureFunctionId = "7c1128f6-fdef-4bf9-8f15-acb54b5bfa89"; // from AzureFunctions (this) module
if (!element.hasStereotype(azureFunctionId)) {
    element.addStereotype(azureFunctionId);
}</script>
        </option>
      </scriptOptions>
      <mappingOptions />
      <typeOrder />
      <mappingSettings />
      <macros>
        <macro trigger="on-changed">
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="domainHelper.ts" /&gt;
class EntityDomainElementDetails {
    constructor(entity) {
        this.entity = entity;
        this.owningEntity = DomainHelper.getOwningAggregate(entity);
    }
    getOwningOrTargetEntityName() {
        var _a;
        return ((_a = this.owningEntity) !== null &amp;&amp; _a !== void 0 ? _a : this.entity).getName();
    }
    hasOwningEntity() {
        return this.owningEntity != null;
    }
}
class MappedDomainElement {
    constructor(originalElement) {
        this.originalElement = originalElement;
        this.entityDomainElementDetails = this.isEntityDomainElement() ? new EntityDomainElementDetails(originalElement) : null;
    }
    isEntityDomainElement() {
        return this.originalElement.specialization == "Class";
    }
    getId() {
        return this.originalElement.id;
    }
    getName() {
        return this.originalElement.getName();
    }
}
/// &lt;reference path="mappedDomainElement.ts" /&gt;
/**
 * Gets the ultimate target entity and it's owning entity (if it has one) of a mapped Command/Query.
 * @param request The Command or Query that has been mapped
 */
function getMappedDomainElement(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId];
    const mappableElements = ["Class", "Repository"];
    const isMappableElement = function (element) {
        return mappableElements.some(x =&gt; (element === null || element === void 0 ? void 0 : element.specialization) === x);
    };
    let entity = null;
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        let element = mappedElement;
        while (element != null) {
            if (isMappableElement(element)) {
                entity = element;
                break;
            }
            element = element.getParent();
        }
    }
    // Advanced mappings:
    if (mappedElement == null) {
        const targetEntities = request.getAssociations()
            .flatMap(association =&gt; association.getMappings()
            .filter(mapping =&gt; mappingTypeIds.some(y =&gt; mapping.mappingTypeId == y))
            .map(mapping =&gt; {
            let element = mapping.getTargetElement();
            while (element != null) {
                if (isMappableElement(element)) {
                    return element;
                }
                element = element.getParent();
            }
            return null;
        })
            .filter(entity =&gt; entity != null));
        // Only if all the targetClasses are the same:
        if (targetEntities.length &gt; 0 &amp;&amp; targetEntities.every(x =&gt; x.id === targetEntities[0].id)) {
            entity = targetEntities[0];
        }
    }
    if (entity == null) {
        return null;
    }
    return new MappedDomainElement(entity);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedDomainElement.ts" /&gt;
/**
 * Used by Intent.Modules.NET\Modules\Intent.Modules.AzureFunctions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/command-azure-functions/command-on-changed/on-changed.ts
 */
(() =&gt; {
    var _a, _b, _c;
    const azureFunctionId = "7c1128f6-fdef-4bf9-8f15-acb54b5bfa89"; // from AzureFunctions (this) module
    const azureFunctionTriggerId = "a6411e1f-8199-4b18-b1a1-fd2aa73b1da6";
    const httpSettingsId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6"; // from WebApi module
    const httpSettingsMediatypeId = "4490e212-1e99-43ce-b3dd-048ed2a6bae8";
    const parameterSettingsId = "d01df110-1208-4af8-a913-92a49d219552"; // from WebApi module
    if (!element.hasStereotype(azureFunctionId)) {
        return;
    }
    if (element.getStereotype(azureFunctionId).getProperty(azureFunctionTriggerId).getValue() !== "Http Trigger") {
        element.removeStereotype(httpSettingsId);
        element.getChildren().forEach(x =&gt; x.removeStereotype(parameterSettingsId));
        return;
    }
    let httpSettings = (_a = element.getStereotype(httpSettingsId)) !== null &amp;&amp; _a !== void 0 ? _a : element.addStereotype(httpSettingsId);
    if (httpSettings.getProperty("Route").getValue()) {
        return;
    }
    const folderName = element.getParent().getName();
    const mappedEntityName = (_b = getMappedDomainElement(element)) === null || _b === void 0 ? void 0 : _b.getName();
    const serviceRoute = toKebabCase(folderName);
    const serviceRouteIdentifier = element.getChildren().some(x =&gt; x.getName().toLowerCase() == `${singularize(folderName.toLowerCase())}id`)
        ? `/{${toCamelCase(singularize(folderName))}Id}`
        : element.getChildren().some(x =&gt; x.getName().toLowerCase() == "id") ? `/{id}` : "";
    const subRoute = mappedEntityName &amp;&amp; mappedEntityName != singularize(folderName) &amp;&amp; serviceRouteIdentifier != `/{id}`
        ? `/${toKebabCase(pluralize(mappedEntityName))}${element.getChildren().some(x =&gt; x.getName().toLowerCase() == "id") ? `/{id}` : ""}`
        : getUnconventionalRoute() != "" ? `/${getUnconventionalRoute()}` : "";
    if (element.getName().startsWith("Create") || element.getName().startsWith("Add")) {
        httpSettings.getProperty("Verb").setValue("POST");
    }
    else if (element.getName().startsWith("Delete") || element.getName().startsWith("Remove")) {
        httpSettings.getProperty("Verb").setValue("DELETE");
    }
    else {
        httpSettings.getProperty("Verb").setValue("PUT");
    }
    httpSettings.getProperty("Route").setValue(`${serviceRoute}${serviceRouteIdentifier}${subRoute}`);
    if (((_c = element.typeReference.getType()) === null || _c === void 0 ? void 0 : _c.specialization) == "Type-Definition") {
        httpSettings.getProperty(httpSettingsMediatypeId).setValue("application/json");
    }
    function getUnconventionalRoute() {
        if ((element.getName().startsWith("Create") ||
            element.getName().startsWith("Update") ||
            element.getName().startsWith("Delete")) &amp;&amp;
            (serviceRouteIdentifier == "" || serviceRouteIdentifier == `/{id}`)) {
            return "";
        }
        let queryRoute = toKebabCase(removeSuffix(removePrefix(element.getName(), "Create", "Update", "Delete"), "Command"));
        return removeSuffix(queryRoute, toKebabCase(mappedEntityName !== null &amp;&amp; mappedEntityName !== void 0 ? mappedEntityName : singularize(folderName)), serviceRoute, "-");
    }
})();
</script>
        </macro>
        <macro trigger="on-changed">
          <script>let azureFunctionId = "7c1128f6-fdef-4bf9-8f15-acb54b5bfa89"; // from AzureFunctions (this) module
let azureFunctionTriggerId = "a6411e1f-8199-4b18-b1a1-fd2aa73b1da6";
let queueOutputBindingId = "ec293aa6-7120-4870-800f-7db01391376f";//from AzureFunctions (this) module

if (element.getStereotype(azureFunctionId)?.getProperty(azureFunctionTriggerId).getValue() !== "Queue Trigger") {
    element.removeStereotype(queueOutputBindingId);
    return;
}

if (element.typeReference == null || element.typeReference.getType() == null ){
    element.removeStereotype(queueOutputBindingId);
} else if (element.getStereotype(queueOutputBindingId) == null) {
    element.addStereotype(queueOutputBindingId);
}
</script>
        </macro>
        <macro trigger="on-changed">
          <script>let azureFunctionId = "7c1128f6-fdef-4bf9-8f15-acb54b5bfa89"; // from AzureFunctions (this) module
let azureFunctionTriggerId = "a6411e1f-8199-4b18-b1a1-fd2aa73b1da6";
let comsmosDBTriggerId = "78edaf9d-bc43-4792-b483-408fcd630261";//from AzureFunctions (this) module

if (element.getStereotype(azureFunctionId)?.getProperty(azureFunctionTriggerId).getValue() !== "Cosmos DB Trigger") {
    element.removeStereotype(comsmosDBTriggerId);
    return;
}

if (element.getStereotype(comsmosDBTriggerId) == null) {
    element.addStereotype(comsmosDBTriggerId);
}
</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0">
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Expose as Azure Function</text>
          <shortcut>ctrl + shift + z</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <script>let azureFunctionId = "7c1128f6-fdef-4bf9-8f15-acb54b5bfa89"; // from AzureFunctions (this) module
if (!element.hasStereotype(azureFunctionId)) {
    element.addStereotype(azureFunctionId);
}</script>
        </option>
      </scriptOptions>
      <mappingOptions />
      <typeOrder />
      <mappingSettings />
      <macros>
        <macro trigger="on-changed">
          <script>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.filterClassSelection(x, options));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return null;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static filterClassSelection(element, options, allowAbstract = false) {
        if (!allowAbstract &amp;&amp; element.getIsAbstract()) {
            return false;
        }
        if (element.hasStereotype("Repository")) {
            return true;
        }
        if ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(element)) {
            return DomainHelper.hasPrimaryKey(element);
        }
        if (DomainHelper.isAggregateRoot(element)) {
            let generalizations = element.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return true;
            }
            let generalization = generalizations[0];
            let parentEntity = generalization.typeReference.getType();
            //Could propagate options here but then we need to update compositional crud to support inheritance and it's already a bit of a hack
            return DomainHelper.filterClassSelection(parentEntity, { includeOwnedRelationships: false }, true);
        }
        return false;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
/// &lt;reference path="domainHelper.ts" /&gt;
class EntityDomainElementDetails {
    constructor(entity) {
        this.entity = entity;
        this.owningEntity = DomainHelper.getOwningAggregate(entity);
    }
    getOwningOrTargetEntityName() {
        var _a;
        return ((_a = this.owningEntity) !== null &amp;&amp; _a !== void 0 ? _a : this.entity).getName();
    }
    hasOwningEntity() {
        return this.owningEntity != null;
    }
}
class MappedDomainElement {
    constructor(originalElement) {
        this.originalElement = originalElement;
        this.entityDomainElementDetails = this.isEntityDomainElement() ? new EntityDomainElementDetails(originalElement) : null;
    }
    isEntityDomainElement() {
        return this.originalElement.specialization == "Class";
    }
    getId() {
        return this.originalElement.id;
    }
    getName() {
        return this.originalElement.getName();
    }
}
/// &lt;reference path="mappedDomainElement.ts" /&gt;
/**
 * Gets the ultimate target entity and it's owning entity (if it has one) of a mapped Command/Query.
 * @param request The Command or Query that has been mapped
 */
function getMappedDomainElement(request) {
    var _a;
    const queryEntityMappingTypeId = "25f25af9-c38b-4053-9474-b0fabe9d7ea7";
    const createEntityMappingTypeId = "5f172141-fdba-426b-980e-163e782ff53e";
    const mappingTypeIds = [queryEntityMappingTypeId, createEntityMappingTypeId];
    const mappableElements = ["Class", "Repository"];
    const isMappableElement = function (element) {
        return mappableElements.some(x =&gt; (element === null || element === void 0 ? void 0 : element.specialization) === x);
    };
    let entity = null;
    // Basic mapping:
    let mappedElement = (_a = request.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement();
    if (mappedElement != null) {
        let element = mappedElement;
        while (element != null) {
            if (isMappableElement(element)) {
                entity = element;
                break;
            }
            element = element.getParent();
        }
    }
    // Advanced mappings:
    if (mappedElement == null) {
        const targetEntities = request.getAssociations()
            .flatMap(association =&gt; association.getMappings()
            .filter(mapping =&gt; mappingTypeIds.some(y =&gt; mapping.mappingTypeId == y))
            .map(mapping =&gt; {
            let element = mapping.getTargetElement();
            while (element != null) {
                if (isMappableElement(element)) {
                    return element;
                }
                element = element.getParent();
            }
            return null;
        })
            .filter(entity =&gt; entity != null));
        // Only if all the targetClasses are the same:
        if (targetEntities.length &gt; 0 &amp;&amp; targetEntities.every(x =&gt; x.id === targetEntities[0].id)) {
            entity = targetEntities[0];
        }
    }
    if (entity == null) {
        return null;
    }
    return new MappedDomainElement(entity);
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/getMappedDomainElement.ts" /&gt;
/**
 * Used by Intent.Modules.NET\Modules\Intent.Modules.AzureFunctions
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/azure-functions/query-on-changed/query-on-changed.ts
 */
(() =&gt; {
    var _a, _b;
    const azureFunctionId = "7c1128f6-fdef-4bf9-8f15-acb54b5bfa89"; // from AzureFunctions (this) module
    const azureFunctionTriggerId = "a6411e1f-8199-4b18-b1a1-fd2aa73b1da6";
    const httpSettingsId = "b4581ed2-42ec-4ae2-83dd-dcdd5f0837b6"; // from WebApi module
    const parameterSettingsId = "d01df110-1208-4af8-a913-92a49d219552"; // from WebApi module
    if (!element.hasStereotype(azureFunctionId)) {
        return;
    }
    if (element.getStereotype(azureFunctionId).getProperty(azureFunctionTriggerId).getValue() !== "Http Trigger") {
        element.removeStereotype(httpSettingsId);
        element.getChildren().forEach(x =&gt; x.removeStereotype(parameterSettingsId));
        return;
    }
    const httpSettings = (_a = element.getStereotype(httpSettingsId)) !== null &amp;&amp; _a !== void 0 ? _a : element.addStereotype(httpSettingsId);
    const folderName = element.getParent().getName();
    const mappedEntityName = (_b = getMappedDomainElement(element)) === null || _b === void 0 ? void 0 : _b.getName();
    if (httpSettings.getProperty("Route").getValue()) {
        return;
    }
    const serviceRoute = toKebabCase(folderName);
    const serviceRouteIdentifier = element.getChildren().some(x =&gt; x.getName().toLowerCase() == `${singularize(folderName.toLowerCase())}id`)
        ? `/{${toCamelCase(singularize(folderName))}Id}`
        : element.getChildren().some(x =&gt; x.getName().toLowerCase() == "id") ? `/{id}` : "";
    const subRoute = mappedEntityName &amp;&amp; mappedEntityName != singularize(folderName) &amp;&amp; serviceRouteIdentifier != `/{id}`
        ? `/${toKebabCase(pluralize(mappedEntityName))}${element.getChildren().some(x =&gt; x.getName().toLowerCase() == "id") ? `/{id}` : ""}`
        : getUnconventionalRoute() != "" ? `/${getUnconventionalRoute()}` : "";
    httpSettings.getProperty("Verb").setValue("GET");
    httpSettings.getProperty("Route").setValue(`${serviceRoute}${serviceRouteIdentifier}${subRoute}`);
    function getUnconventionalRoute() {
        if ((element.getName().startsWith("Get") ||
            element.getName().startsWith("Find") ||
            element.getName().startsWith("Lookup")) &amp;&amp;
            (serviceRouteIdentifier == `/{id}`)) {
            return "";
        }
        const queryRoute = toKebabCase(removeSuffix(removePrefix(element.getName(), "Get", "Find", "Lookup"), "Query"));
        return removePrefix(queryRoute, serviceRoute, toKebabCase(mappedEntityName !== null &amp;&amp; mappedEntityName !== void 0 ? mappedEntityName : singularize(folderName)), "-");
    }
})();
</script>
        </macro>
      </macros>
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions />
  <mappingSettings />
  <mappableElementPackages />
  <mappableElementPackageExtensions />
</settings>