<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>46410048-55e6-4cc9-8ee0-dcd0e24a8ee2</id>
  <name>MediatR CRUD Extensions</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions>
    <packageExtension type="Services Package" typeId="df45eaf6-9202-4c25-8dd5-677e9ba1e906">
      <requiredPackages />
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CRUD Service</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="FontAwesome" source="code" />
          <script>// Detect if we're running from the "Execution Script dialogue", in which case we want to manually
// set the element to something:
let defaultDomainClassName = null;
if (element?.id == null) {
    // For testing as if a package was right clicked, substitute with package id:
    element = getPackages().filter(x =&gt; x.id == "eafc12ee-88c0-4e8e-abcf-2b989be5d656")[0];

    // For element, substitute with service's element id:
    // element = lookup("677c6801-e654-45c5-924e-886713db1f5e");

    // When set, the dialog asking to select the class from the domain is skipped:
    defaultDomainClassName = "NewClass";
}

initConstants();

let entity = await preselectOrPromptEntity(defaultDomainClassName);
if (!entity) { return; }
let service = getServiceFromCurrentContext(entity, element);

let entityFolder = getEntityFolder(service, entity);
let resultCqrsTypeDto = createCqrsResultTypeDTO(entity, entityFolder);

createCqrsCreateOperation(service, entityFolder, entity);
createCqrsFindByIdOperation(service, entity, entityFolder, resultCqrsTypeDto);
createCqrsFindAllOperation(service, entity, entityFolder, resultCqrsTypeDto);
createCqrsUpdateOperation(service, entity, entityFolder);
createCqrsDeleteOperation(service, entity, entityFolder);

/*
========================
   HOOK-IN FUNCTIONS
========================
Easier to alter the behavior of certain key operations.
Could make certain things configurable in the future.
*/

function getParameterFormat(str) {
    return toCamelCase(str);
}

function getRoutingFormat(str) {
    return str;
}

function getFieldFormat(str) {
    return toPascalCase(str);
}

function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}

function getFolderName(nestedCompOwner, entity) {
    return nestedCompOwner ? pluralize(nestedCompOwner.name) : pluralize(entity.name);
}

function getBaseNameForElement(nestedCompOwner, entity, entityIsMany) {
    let entityName = entityIsMany ? toPascalCase(pluralize(entity.name)) : toPascalCase(entity.name);
    return nestedCompOwner ? `${toPascalCase(nestedCompOwner.name)}${entityName}` : entityName;
}

function getServiceName(nestedCompOwner, entity) {
    return nestedCompOwner 
        ? `${toPascalCase(nestedCompOwner.name)}Service` 
        : `${toPascalCase(entity.name)}Service`;
}

function getOperationFormat(baseName, nestedCompOwner, entity, entityIsMany) {
    let entityName = entityIsMany ? pluralize(entity.name) : entity.name;
    return `${baseName}${nestedCompOwner ? entityName : ""}`;
}

/*
========================
   CREATION FUNCTIONS
========================
*/

function createCqrsResultTypeDTO(entity, entityFolder) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedDtoName = `${baseName}DTO`;

    if (hasElementInFolder(entityFolder, expectedDtoName)) {
        return entityFolder.getChildren().filter(x =&gt; x.name == expectedDtoName)[0];
    }

    let dto = createElement("DTO", expectedDtoName, entityFolder.id);
    dto.setMapping(entity.id);
    dto.setMetadata("baseName", baseName);

    let entityPkDescr = getPrimaryKeyDescriptor(entity);

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);

        if (!nestedCompOwnerFkDescr || nestedCompOwnerFkDescr.specialization == FKSpecialization.Implicit) {
            let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), dto.id);
            nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        }
    }

    if (entityPkDescr.specialization == PKSpecialization.Implicit) {
        let idField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
        idField.typeReference.setType(entityPkDescr.typeId);
    }

    for (let attribute of entity.getChildren("Attribute")) {
        let field = createElement("DTO-Field", getFieldFormat(attribute.name), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
    }

    dto.collapse();
    return dto;
}

function createCqrsCreateOperation(service, entityFolder, entity) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedCommandName = `Create${baseName}Command`;
    
    if (hasElementInFolder(entityFolder, expectedCommandName)) {
        let command = entityFolder.getChildren().filter(x =&gt; x.name == expectedCommandName)[0];
        let entityPkDescr = getPrimaryKeyDescriptor(entity);
        command.typeReference.setType(entityPkDescr.typeId);
        return;
    }

    let command = createElement("Command", expectedCommandName, entityFolder.id);
    command.setMapping(entity.id);
    command.setMetadata("baseName", baseName);

    let operation = createElement("Operation", getOperationFormat("Post", nestedCompOwner, entity), service.id);
    operation.setMapping(command.id);

    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);

        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), command.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId)
        if (nestedCompOwnerFkDescr.specialization == FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }

        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        param.setMapping(nestedCompOwnerIdDtoField.id);

        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, null);
    }

    setHttpStereotype(operation, "Http Settings", {"Verb": "POST", "Route": routePath});

    let operationParamCommand = createElement("Parameter", getParameterFormat("command"), operation.id);
    operationParamCommand.typeReference.setType(command.id);

    if (entityPkDescr.typeId) {
        command.typeReference.setType(entityPkDescr.typeId);
        getReturnTypeMediatypeProperty(operation).setValue("application/json");
    }

    for (let attribute of entity.getChildren("Attribute")
        // For Create Commands, we don't want to by default have PKs and FKs
        .filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Foreign Key"))) {
            let field = createElement("DTO-Field", getFieldFormat(attribute.name), command.id);
            field.typeReference.setType(attribute.typeReference.typeId)
            field.setMapping(attribute.id);
    }

    command.collapse();
    operation.collapse();
}

function createCqrsFindByIdOperation(service, entity, entityFolder, resultTypeDto) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedQueryName = `Get${baseName}ByIdQuery`;
    
    if (hasElementInFolder(entityFolder, expectedQueryName)) {
        return;
    }

    let query = createElement("Query", expectedQueryName, entityFolder.id);
    query.typeReference.setType(resultTypeDto.id)
    query.setMapping(entity.id);
    query.setMetadata("baseName", baseName);

    let operation = createElement("Operation", getOperationFormat("Get", nestedCompOwner, entity), service.id);
    operation.setMapping(query.id);

    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        
        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), query.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        if (nestedCompOwnerFkDescr.specialization == FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }

        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        param.setMapping(nestedCompOwnerIdDtoField.id);

        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    } else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }

    setHttpStereotype(operation, "Http Settings", {"Verb": "GET", "Route": routePath});
    addPrimaryKeys(query, operation, entityPkDescr);

    query.collapse();
    operation.collapse();
}

function createCqrsFindAllOperation(service, entity, entityFolder, resultTypeDto) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, true);
    let expectedQueryName = `Get${baseName}Query`;
    
    if (hasElementInFolder(entityFolder, expectedQueryName)) {
        return;
    }

    let query = createElement("Query", expectedQueryName, entityFolder.id);
    query.typeReference.setType(resultTypeDto.id)
    query.typeReference.setIsCollection(true);
    query.setMetadata("baseName", baseName);

    let operation = createElement("Operation", getOperationFormat("Get", nestedCompOwner, entity, true), service.id);
    operation.setMapping(query.id);

    let routePath = "";

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);

        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), query.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);

        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        param.setMapping(nestedCompOwnerIdDtoField.id);

        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, null);
    }

    setHttpStereotype(operation, "Http Settings", {"Verb": "GET", "Route": routePath});

    query.collapse();
    operation.collapse();
}

function createCqrsUpdateOperation(service, entity, entityFolder) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedCommandName = `Update${baseName}Command`;

    if (hasElementInFolder(entityFolder, expectedCommandName)) {
        return;
    }

    let command = createElement("Command", expectedCommandName, entityFolder.id);
    command.setMapping(entity.id);
    command.setMetadata("baseName", baseName);

    let operation = createElement("Operation", getOperationFormat("Put", nestedCompOwner, entity), service.id);
    operation.setMapping(command.id);

    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);

        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), command.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId)
        if (nestedCompOwnerFkDescr.specialization == FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }

        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        param.setMapping(nestedCompOwnerIdDtoField.id);

        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    } else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }

    setHttpStereotype(operation, "Http Settings", {"Verb": "PUT", "Route": routePath});
    addPrimaryKeys(command, operation, entityPkDescr);

    let commandParam = createElement("Parameter", getParameterFormat("command"), operation.id);
    commandParam.typeReference.setType(command.id);

    for (let attribute of entity.getChildren("Attribute")
        .filter(attr =&gt; !hasAttributeInCommand(command, attr))) {
            let field = createElement("DTO-Field", getFieldFormat(attribute.name), command.id);
            field.typeReference.setType(attribute.typeReference.typeId)
            field.setMapping(attribute.id);
    }

    command.collapse();
    operation.collapse();

    function hasAttributeInCommand(command, attribute) {
        return command.getChildren("DTO-Field").some(x =&gt; x.name == attribute.name);
    }
}

function createCqrsDeleteOperation(service, entity, entityFolder) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedCommandName = `Delete${baseName}Command`;

    if (hasElementInFolder(entityFolder, expectedCommandName)) {
        return;
    }

    let command = createElement("Command", expectedCommandName, entityFolder.id);
    command.setMapping(entity.id);
    command.setMetadata("baseName", baseName);

    let operation = createElement("Operation", getOperationFormat("Delete", nestedCompOwner, entity), service.id);
    operation.setMapping(command.id);

    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);

        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), command.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId)
        if (nestedCompOwnerFkDescr.specialization == FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }

        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        param.setMapping(nestedCompOwnerIdDtoField.id);

        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    } else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }

    setHttpStereotype(operation, "Http Settings", {"Verb": "DELETE", "Route": routePath});
    addPrimaryKeys(command, operation, entityPkDescr);

    let commandParam = createElement("Parameter", getParameterFormat("command"), operation.id);
    commandParam.typeReference.setType(command.id);

    command.collapse();
    operation.collapse();
}

/*
========================
   UTILITY FUNCTIONS
========================
*/

function initConstants() {
    _aggregateRootCache = Object.create(null);
    _nestedCompositionalOwnerCache = Object.create(null);

    PKSpecialization = {
        Implicit: "implicit",
        Explicit: "explicit",
        ExplicitComposite: "explicit_composite",
        Unknown: "unknown"
    };
    FKSpecialization = {
        Implicit: "implicit",
        Explicit: "explicit",
    };
}

async function showObject(object) {
    await dialogService.info(JSON.stringify(object, null, "  "));
}

async function preselectOrPromptEntity(preselectedDomainClassName) {
    let classes = lookupTypesOf("Class").filter(x =&gt; isAggregateRoot(x) || x.hasStereotype("Repository") || ownerIsAggregateRoot(x));
    if (classes.length == 0) {
        await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
        return;
    }

    let classId = preselectedDomainClassName != null
        ? classes.find(x =&gt; x.getName() === preselectedDomainClassName)?.id
        : await dialogService.lookupFromOptions(classes.map((x)=&gt;({
            id: x.id, 
            name: getFriendlyDisplayNameForClassSelection(x)
            })));
    if (classId == null) {
        await dialogService.error(`No class found with id "${classId}".`);
        return null;
    }

    let foundEntity = lookup(classId);
    return foundEntity;
}

function getFriendlyDisplayNameForClassSelection(element) {
    let found = element.getAssociations("Association").filter(x =&gt; x.isSourceEnd() &amp;&amp; 
            !x.typeReference.isNullable &amp;&amp; 
            !x.typeReference.isCollection &amp;&amp; 
            isAggregateRoot(x.typeReference.getType()))[0]?.typeReference?.getType();
    return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
}

function getServiceFromCurrentContext(entity, packageOrServiceElement) {
    // Auto detect if we're running in the context of a service or package.
    if (packageOrServiceElement.specialization === "Service") {
        return packageOrServiceElement;
    }

    // Must be a package. See if we can find an existing service with the name we expect.
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let expectedServiceName = getServiceName(nestedCompOwner, entity);
    let services = packageOrServiceElement.getChildren("Service").filter(x =&gt; x.name === expectedServiceName);
    if (services.length &gt; 0) {
        return services[0];
    }

    return createElement("Service", expectedServiceName, packageOrServiceElement.id);
}

function getReturnTypeMediatypeProperty(element) {
    return element.getStereotype("Http Settings").getProperty("Return Type Mediatype");
}

function isAggregateRoot(element) {
    if (_aggregateRootCache[element.id]) {
        return _aggregateRootCache[element.id];
    }
    let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
    _aggregateRootCache[element.id] = result;
    return result;
}

function getNestedCompositionalOwner(entity) {
    if (_nestedCompositionalOwnerCache[entity.id]) {
        return _nestedCompositionalOwnerCache[entity.id];
    }

    let result = entity.getAssociations("Association")
        .filter(x =&gt; isAggregateRoot(x.typeReference.getType()) &amp;&amp;
            isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection) [0];
    if(result) {
        _nestedCompositionalOwnerCache[entity.id] = result.typeReference.getType();
    }
    return result;

    function isOwnedBy(association) {
        return association.isSourceEnd() &amp;&amp; 
            !association.typeReference.isNullable &amp;&amp; 
            !association.typeReference.isCollection;
    }
}

function ownerIsAggregateRoot(entity) {
    let result = getNestedCompositionalOwner(entity);
    return result ? true : false;
}

function getEntityFolder(service, entity) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let expectedFolderName = getFolderName(nestedCompOwner, entity);
    var existing = service.getParent().getChildren().find(x =&gt; x.name == expectedFolderName);
    var folder = existing || createElement("Folder", expectedFolderName, service.getParent().id);
    return folder;
}

function hasElementInFolder(entityFolder, expectedElementName) {
    return entityFolder.getChildren().some(x =&gt; x.name == expectedElementName);
}

function setHttpStereotype(element, stereotypeName, props) {
    let stereotype = element.getStereotype(stereotypeName);
    for (let key of Object.keys(props)) {
        stereotype.getProperty(key).setValue(props[key]);
    }
}

function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");

    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }

    return typeNameToIdMap.get("guid");
}

// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getPrimaryKeyDescriptor(entity) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    let pks = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    switch (true) {
        case pks.length == 0:
            return {
                id: null,
                name: getDomainAttributeNameFormat("Id"),
                typeId: getSurrogateKeyType(),
                specialization: PKSpecialization.Implicit,
                compositeKeys: null
            };
        case pks.length == 1:
            let pkAttr = pks[0];
            return {
                id: pkAttr.id,
                name: getDomainAttributeNameFormat(pkAttr.name),
                typeId: pkAttr.typeReference.typeId,
                specialization: PKSpecialization.Explicit,
                compositeKeys: null
            };
        case pks.length &gt; 1:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: PKSpecialization.ExplicitComposite,
                compositeKeys: pks.map(x =&gt; { 
                    return {
                        id: x.id,
                        name: getDomainAttributeNameFormat(x.name),
                        typeId: x.typeReference.typeId
                    }; 
                })
            };
        default:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: PKSpecialization.Unknown,
                compositeKeys: null
            };
    }
}

// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    if (!nestedCompOwner) {
        throw new Error("nestedCompOwner not specified");
    }

    let explicitFkAttr = entity.getChildren("Attribute")
        .filter(x =&gt; x.name.toLowerCase().indexOf(nestedCompOwner.name.toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
    
    if (explicitFkAttr) {
        return {
            name: getDomainAttributeNameFormat(explicitFkAttr.name),
            typeId: explicitFkAttr.typeReference.typeId,
            id: explicitFkAttr.id,
            specialization: FKSpecialization.Explicit
        };
    }
    
    return {
        name: getDomainAttributeNameFormat(`${nestedCompOwner.name}Id`),
        typeId: getSurrogateKeyType(),
        id: null,
        specialization: FKSpecialization.Implicit
    };
}

function addPrimaryKeys(commandQuery, operation, entityPkDescr) {
    switch (entityPkDescr.specialization) {
        case PKSpecialization.Implicit:
        case PKSpecialization.Explicit:
            {
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), commandQuery.id);
                primaryKeyDtoField.typeReference.setType(entityPkDescr.typeId);
                if (entityPkDescr.specialization == PKSpecialization.Explicit) {
                    primaryKeyDtoField.setMapping(entityPkDescr.id);
                }

                let operationParamId = createElement("Parameter", getParameterFormat(entityPkDescr.name), operation.id);
                operationParamId.typeReference.setType(primaryKeyDtoField.typeReference.typeId);
                operationParamId.setMapping(primaryKeyDtoField.id);
            }
            break;
        case PKSpecialization.ExplicitComposite:
            for (let key of entityPkDescr.compositeKeys) {
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(key.name), commandQuery.id);
                primaryKeyDtoField.typeReference.setType(key.typeId)
                primaryKeyDtoField.setMapping(key.id);

                let operationParamId = createElement("Parameter", getParameterFormat(key.name), operation.id);
                operationParamId.typeReference.setType(primaryKeyDtoField.typeReference.typeId);
                operationParamId.setMapping(primaryKeyDtoField.id);
            }
            break;
    }
}

function getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr) {
    let list = []
    if(nestedCompOwnerFkDescr) {
        list.push(`{${getParameterFormat(nestedCompOwnerFkDescr.name)}}`);
    }
    if(entity) {
        list.push(`${getRoutingFormat(entity.name)}`);
    }
    if (entityPkDescr) {
        switch (entityPkDescr.specialization) {
            case PKSpecialization.Implicit:
            case PKSpecialization.Explicit:
                list.push(`{${getParameterFormat(entityPkDescr.name)}}`);
                break;
            case PKSpecialization.ExplicitComposite:
                list.push(entityPkDescr.compositeKeys.map(x =&gt; `{${getParameterFormat(x.name)}}`))
                break;
        }
    }
    if (list.length == 0) {
        return "";
    }
    return list.join("/");
}

function getDomainAttributeNamingConvention() {
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return application.getSettings(domainSettingsId)
        ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
}</script>
        </option>
      </scriptOptions>
      <typeOrder />
    </packageExtension>
  </packageExtensions>
  <elementSettings />
  <elementExtensions>
    <elementExtension type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9">
      <mappingSettings />
      <macros>
        <macro trigger="on-mapped">
          <script>//let element = lookup("29a81107-c71c-45b4-ba7b-982be63277a1")

const projectMapptingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";

let fields = element.getChildren("DTO-Field")
    .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");

fields.forEach(f =&gt; {
    let mappedElement = f.getMapping().getElement();

    let originalVerb = (element.getName().split(/(?=[A-Z])/))[0];

    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName") 
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName =  `${originalVerb}${baseName}`;
    let dto = getOrCreateDTO(dtoName, element.getParent());
    dto.setMetadata("originalVerb", originalVerb);
    dto.setMetadata("baseName", baseName);
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMapptingSettingId);

    ensureDtoFields(mappedElement, dto);
    
    f.typeReference.setType(dto.id);
});

function getOrCreateDTO(elementName, parentElement) {
    const expectedDtoName = `${elementName}DTO`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.name === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }

    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}

function ensureDtoFields(mappedElement, dto) {
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let mappedElementAttributes = domainElement
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;

    for (let attribute of mappedElementAttributes.filter(x =&gt; ! dtoFields.some(y =&gt; x.name === y.name))) {
        if (isCreateMode &amp;&amp; attribute.name?.toLowerCase() === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(attribute, domainElement)) {
            continue;
        }
        if (attribute.hasStereotype("Partition Key")) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.name, dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }

    let explicitPk = dto.getChildren("DTO-Field").filter(x =&gt; x.getMapping()?.getElement()?.hasStereotype("Primary Key") || x.getName().toLowerCase() === "id")[0];
    if (!isCreateMode &amp;&amp; !explicitPk) {
        let field = createElement("DTO-Field", "id", dto.id);
        field.typeReference.setType(getSurrogateKeyType());
    }

    if (dtoUpdated) {
        dto.collapse();
    }
}

function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");

    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }

    return typeNameToIdMap.get("guid");
}

function isOwnerForeignKey(attribute, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attribute.name.toLowerCase().indexOf(association.name.toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="DTO" typeId="fee0edca-4aa0-4f77-a524-6bbd84e78734">
      <mappingSettings>
        <mappingSetting id="942eae46-49f1-450e-9274-a92d40ac35fa">
          <name>Project to Domain</name>
          <shortcut>ctrl + shift + p</shortcut>
          <defaultModeler>6ab29b31-27af-4f56-a67c-986d82097d63</defaultModeler>
          <optionsSource>elements-of-type</optionsSource>
          <autoSyncTypeReferences>true</autoSyncTypeReferences>
          <symbol>fa-long-arrow-right</symbol>
          <targetTypeOptions>
            <option specializationType="04e12b51-ed12-42a3-9667-a6aa81bb6d10" displayText="Class" />
            <option specializationType="5fe6bb0a-7fc3-42ae-a351-d9188f5b8bc5" displayText="Value Object" />
          </targetTypeOptions>
          <mapFrom>root</mapFrom>
          <mappings>
            <mapping id="64ebfd83-8720-407a-9308-d6a293873861">
              <criteria specializationType="Class">
                <hasTypeReference p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <isCollection p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <hasChildren p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
              </criteria>
              <mapTo specializationType="DTO" childMappingMode="map-to-child" />
              <behaviour autoSelectChildren="true" />
              <childMappings>
                <mapping id="270e081f-8e9b-46ef-8199-b22860549026">
                  <criteria specializationType="Attribute">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren>false</hasChildren>
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="8841b8bd-7e0f-4903-a3b5-df7447fda037">
                  <criteria specializationType="Association Target End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="90d2281b-0c25-4540-a9f9-3f81ef804f34">
                  <criteria specializationType="Association Source End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="997ed56f-d99d-4c25-8c9e-7cf7f01078f5">
                  <criteria specializationType="Generalization Target End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection>false</isCollection>
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo childMappingMode="traverse" useMappingSettings="64ebfd83-8720-407a-9308-d6a293873861" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
              </childMappings>
            </mapping>
            <mapping id="7a05fe8c-62d8-40e8-b6cf-c1ad30da801e">
              <criteria specializationType="Value Object">
                <hasTypeReference p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <isCollection p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <hasChildren p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
              </criteria>
              <mapTo specializationType="DTO" childMappingMode="map-to-child" />
              <behaviour autoSelectChildren="true" />
              <childMappings>
                <mapping id="88887618-18ad-4240-8051-e95ebccf244a">
                  <criteria specializationType="Attribute">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren>false</hasChildren>
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
              </childMappings>
            </mapping>
          </mappings>
        </mappingSetting>
      </mappingSettings>
      <macros>
        <macro trigger="on-mapped">
          <script>//let element = lookup("29a81107-c71c-45b4-ba7b-982be63277a1")

const projectMapptingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
const originalDtoMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";

let fields = element.getChildren("DTO-Field")
    .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");

fields.forEach(f =&gt; {
    let mappedElement = f.getMapping().getElement();

    let originalVerb = "";
    if (element.hasMetadata("originalVerb")) {
        originalVerb = element.getMetadata("originalVerb");
        // In the event that the prefix is no longer the same as the
        // originally called verb, then don't propagate this any further
        // as end users might get confused.
        if (element.getName().indexOf(originalVerb) != 0) {
            originalVerb = "";
        }
    }

    let targetMappingSettingId = (!originalVerb || originalVerb === "") 
        ? originalDtoMappingSettingId 
        : projectMapptingSettingId;

    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName") 
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName =  `${originalVerb}${baseName}`;
    let dto = getOrCreateDTO(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), targetMappingSettingId);
    if (originalVerb !== "") {
        dto.setMetadata("originalVerb", originalVerb);
    }
    dto.setMetadata("baseName", baseName);
    ensureDtoFields(mappedElement, dto);
    
    f.typeReference.setType(dto.id);
});

function getOrCreateDTO(elementName, parentElement) {
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.name === `${elementName}DTO`)[0];
    if (existingDto) {
        return existingDto;
    }

    let dto = createElement("DTO", `${elementName}DTO`, parentElement.id);
    return dto;
}

function ensureDtoFields(mappedElement, dto) {
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let mappedElementAttributes = domainElement
        .getChildren("Attribute");
    let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; ! dtoFields.some(y =&gt; x.name === y.name))) {
        if (isCreateMode &amp;&amp; attribute.name?.toLowerCase() === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(attribute, domainElement)) {
            continue;
        }
        if (attribute.hasStereotype("Partition Key")) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.name, dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }

    let explicitPk = dto.getChildren("DTO-Field").filter(x =&gt; x.getMapping()?.getElement()?.hasStereotype("Primary Key") || x.getName().toLowerCase() === "id")[0];
    if (!isCreateMode &amp;&amp; !explicitPk) {
        let field = createElement("DTO-Field", "id", dto.id);
        field.typeReference.setType(getSurrogateKeyType());
    }

    if (dtoUpdated) {
        dto.collapse();
    }
}

function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");

    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }

    return typeNameToIdMap.get("guid");
}

function isOwnerForeignKey(attribute, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attribute.name.toLowerCase().indexOf(association.name.toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0">
      <mappingSettings />
      <macros>
        <macro trigger="on-mapped">
          <script>//let element = lookup("29a81107-c71c-45b4-ba7b-982be63277a1")

const projectMapptingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";

let fields = element.getChildren("DTO-Field")
    .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");

fields.forEach(f =&gt; {
    let mappedElement = f.getMapping().getElement();

    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName") 
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName =  baseName;
    let dto = getOrCreateDTO(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMapptingSettingId);
    dto.setMetadata("baseName", baseName);

    ensureDtoFields(mappedElement, dto);
    
    f.typeReference.setType(dto.id);
});

function getOrCreateDTO(elementName, parentElement) {
    const expectedQueryName = `${elementName}DTO`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.name === expectedQueryName)[0];
    if (existingDto) {
        return existingDto;
    }

    let dto = createElement("DTO", expectedQueryName, parentElement.id);
    return dto;
}

function ensureDtoFields(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; ! dtoFields.some(y =&gt; x.name === y.name))) {
        if (attribute.hasStereotype("Partition Key")) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.name, dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }

    if (dtoUpdated) {
        dto.collapse();
    }
}</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Service" typeId="b16578a5-27b1-4047-a8df-f0b783d706bd">
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CRUD Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="FontAwesome" source="code" />
          <script>// Detect if we're running from the "Execution Script dialogue", in which case we want to manually
// set the element to something:
let defaultDomainClassName = null;
if (element?.id == null) {
    // For testing as if a package was right clicked, substitute with package id:
    element = getPackages().filter(x =&gt; x.id == "eafc12ee-88c0-4e8e-abcf-2b989be5d656")[0];

    // For element, substitute with service's element id:
    // element = lookup("677c6801-e654-45c5-924e-886713db1f5e");

    // When set, the dialog asking to select the class from the domain is skipped:
    defaultDomainClassName = "NewClass";
}

initConstants();

let entity = await preselectOrPromptEntity(defaultDomainClassName);
if (!entity) { return; }
let service = getServiceFromCurrentContext(entity, element);

let entityFolder = getEntityFolder(service, entity);
let resultCqrsTypeDto = createCqrsResultTypeDTO(entity, entityFolder);

createCqrsCreateOperation(service, entityFolder, entity);
createCqrsFindByIdOperation(service, entity, entityFolder, resultCqrsTypeDto);
createCqrsFindAllOperation(service, entity, entityFolder, resultCqrsTypeDto);
createCqrsUpdateOperation(service, entity, entityFolder);
createCqrsDeleteOperation(service, entity, entityFolder);

/*
========================
   HOOK-IN FUNCTIONS
========================
Easier to alter the behavior of certain key operations.
Could make certain things configurable in the future.
*/

function getParameterFormat(str) {
    return toCamelCase(str);
}

function getRoutingFormat(str) {
    return str;
}

function getFieldFormat(str) {
    return toPascalCase(str);
}

function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}

function getFolderName(nestedCompOwner, entity) {
    return nestedCompOwner ? pluralize(nestedCompOwner.name) : pluralize(entity.name);
}

function getBaseNameForElement(nestedCompOwner, entity, entityIsMany) {
    let entityName = entityIsMany ? toPascalCase(pluralize(entity.name)) : toPascalCase(entity.name);
    return nestedCompOwner ? `${toPascalCase(nestedCompOwner.name)}${entityName}` : entityName;
}

function getServiceName(nestedCompOwner, entity) {
    return nestedCompOwner 
        ? `${toPascalCase(nestedCompOwner.name)}Service` 
        : `${toPascalCase(entity.name)}Service`;
}

function getOperationFormat(baseName, nestedCompOwner, entity, entityIsMany) {
    let entityName = entityIsMany ? pluralize(entity.name) : entity.name;
    return `${baseName}${nestedCompOwner ? entityName : ""}`;
}

/*
========================
   CREATION FUNCTIONS
========================
*/

function createCqrsResultTypeDTO(entity, entityFolder) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedDtoName = `${baseName}DTO`;

    if (hasElementInFolder(entityFolder, expectedDtoName)) {
        return entityFolder.getChildren().filter(x =&gt; x.name == expectedDtoName)[0];
    }

    let dto = createElement("DTO", expectedDtoName, entityFolder.id);
    dto.setMapping(entity.id);
    dto.setMetadata("baseName", baseName);

    let entityPkDescr = getPrimaryKeyDescriptor(entity);

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);

        if (!nestedCompOwnerFkDescr || nestedCompOwnerFkDescr.specialization == FKSpecialization.Implicit) {
            let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), dto.id);
            nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        }
    }

    if (entityPkDescr.specialization == PKSpecialization.Implicit) {
        let idField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
        idField.typeReference.setType(entityPkDescr.typeId);
    }

    for (let attribute of entity.getChildren("Attribute")) {
        let field = createElement("DTO-Field", getFieldFormat(attribute.name), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
    }

    dto.collapse();
    return dto;
}

function createCqrsCreateOperation(service, entityFolder, entity) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedCommandName = `Create${baseName}Command`;
    
    if (hasElementInFolder(entityFolder, expectedCommandName)) {
        let command = entityFolder.getChildren().filter(x =&gt; x.name == expectedCommandName)[0];
        let entityPkDescr = getPrimaryKeyDescriptor(entity);
        command.typeReference.setType(entityPkDescr.typeId);
        return;
    }

    let command = createElement("Command", expectedCommandName, entityFolder.id);
    command.setMapping(entity.id);
    command.setMetadata("baseName", baseName);

    let operation = createElement("Operation", getOperationFormat("Post", nestedCompOwner, entity), service.id);
    operation.setMapping(command.id);

    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);

        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), command.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId)
        if (nestedCompOwnerFkDescr.specialization == FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }

        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        param.setMapping(nestedCompOwnerIdDtoField.id);

        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, null);
    }

    setHttpStereotype(operation, "Http Settings", {"Verb": "POST", "Route": routePath});

    let operationParamCommand = createElement("Parameter", getParameterFormat("command"), operation.id);
    operationParamCommand.typeReference.setType(command.id);

    if (entityPkDescr.typeId) {
        command.typeReference.setType(entityPkDescr.typeId);
        getReturnTypeMediatypeProperty(operation).setValue("application/json");
    }

    for (let attribute of entity.getChildren("Attribute")
        // For Create Commands, we don't want to by default have PKs and FKs
        .filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Foreign Key"))) {
            let field = createElement("DTO-Field", getFieldFormat(attribute.name), command.id);
            field.typeReference.setType(attribute.typeReference.typeId)
            field.setMapping(attribute.id);
    }

    command.collapse();
    operation.collapse();
}

function createCqrsFindByIdOperation(service, entity, entityFolder, resultTypeDto) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedQueryName = `Get${baseName}ByIdQuery`;
    
    if (hasElementInFolder(entityFolder, expectedQueryName)) {
        return;
    }

    let query = createElement("Query", expectedQueryName, entityFolder.id);
    query.typeReference.setType(resultTypeDto.id)
    query.setMapping(entity.id);
    query.setMetadata("baseName", baseName);

    let operation = createElement("Operation", getOperationFormat("Get", nestedCompOwner, entity), service.id);
    operation.setMapping(query.id);

    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);
        
        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), query.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        if (nestedCompOwnerFkDescr.specialization == FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }

        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        param.setMapping(nestedCompOwnerIdDtoField.id);

        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    } else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }

    setHttpStereotype(operation, "Http Settings", {"Verb": "GET", "Route": routePath});
    addPrimaryKeys(query, operation, entityPkDescr);

    query.collapse();
    operation.collapse();
}

function createCqrsFindAllOperation(service, entity, entityFolder, resultTypeDto) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, true);
    let expectedQueryName = `Get${baseName}Query`;
    
    if (hasElementInFolder(entityFolder, expectedQueryName)) {
        return;
    }

    let query = createElement("Query", expectedQueryName, entityFolder.id);
    query.typeReference.setType(resultTypeDto.id)
    query.typeReference.setIsCollection(true);
    query.setMetadata("baseName", baseName);

    let operation = createElement("Operation", getOperationFormat("Get", nestedCompOwner, entity, true), service.id);
    operation.setMapping(query.id);

    let routePath = "";

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);

        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), query.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId);

        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        param.setMapping(nestedCompOwnerIdDtoField.id);

        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, null);
    }

    setHttpStereotype(operation, "Http Settings", {"Verb": "GET", "Route": routePath});

    query.collapse();
    operation.collapse();
}

function createCqrsUpdateOperation(service, entity, entityFolder) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedCommandName = `Update${baseName}Command`;

    if (hasElementInFolder(entityFolder, expectedCommandName)) {
        return;
    }

    let command = createElement("Command", expectedCommandName, entityFolder.id);
    command.setMapping(entity.id);
    command.setMetadata("baseName", baseName);

    let operation = createElement("Operation", getOperationFormat("Put", nestedCompOwner, entity), service.id);
    operation.setMapping(command.id);

    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);

        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), command.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId)
        if (nestedCompOwnerFkDescr.specialization == FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }

        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        param.setMapping(nestedCompOwnerIdDtoField.id);

        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    } else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }

    setHttpStereotype(operation, "Http Settings", {"Verb": "PUT", "Route": routePath});
    addPrimaryKeys(command, operation, entityPkDescr);

    let commandParam = createElement("Parameter", getParameterFormat("command"), operation.id);
    commandParam.typeReference.setType(command.id);

    for (let attribute of entity.getChildren("Attribute")
        .filter(attr =&gt; !hasAttributeInCommand(command, attr))) {
            let field = createElement("DTO-Field", getFieldFormat(attribute.name), command.id);
            field.typeReference.setType(attribute.typeReference.typeId)
            field.setMapping(attribute.id);
    }

    command.collapse();
    operation.collapse();

    function hasAttributeInCommand(command, attribute) {
        return command.getChildren("DTO-Field").some(x =&gt; x.name == attribute.name);
    }
}

function createCqrsDeleteOperation(service, entity, entityFolder) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let baseName = getBaseNameForElement(nestedCompOwner, entity, false);
    let expectedCommandName = `Delete${baseName}Command`;

    if (hasElementInFolder(entityFolder, expectedCommandName)) {
        return;
    }

    let command = createElement("Command", expectedCommandName, entityFolder.id);
    command.setMapping(entity.id);
    command.setMetadata("baseName", baseName);

    let operation = createElement("Operation", getOperationFormat("Delete", nestedCompOwner, entity), service.id);
    operation.setMapping(command.id);

    let entityPkDescr = getPrimaryKeyDescriptor(entity);
    let routePath = "";

    if (nestedCompOwner) {
        let nestedCompOwnerFkDescr = getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner);

        let nestedCompOwnerIdDtoField = createElement("DTO-Field", getFieldFormat(nestedCompOwnerFkDescr.name), command.id);
        nestedCompOwnerIdDtoField.typeReference.setType(nestedCompOwnerFkDescr.typeId)
        if (nestedCompOwnerFkDescr.specialization == FKSpecialization.Explicit) {
            nestedCompOwnerIdDtoField.setMapping(nestedCompOwnerFkDescr.id);
        }

        let param = createElement("Parameter", getParameterFormat(nestedCompOwnerFkDescr.name), operation.id);
        param.typeReference.setType(nestedCompOwnerFkDescr.typeId);
        param.setMapping(nestedCompOwnerIdDtoField.id);

        routePath = getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr);
    } else {
        routePath = getRoutePath(null, null, entityPkDescr);
    }

    setHttpStereotype(operation, "Http Settings", {"Verb": "DELETE", "Route": routePath});
    addPrimaryKeys(command, operation, entityPkDescr);

    let commandParam = createElement("Parameter", getParameterFormat("command"), operation.id);
    commandParam.typeReference.setType(command.id);

    command.collapse();
    operation.collapse();
}

/*
========================
   UTILITY FUNCTIONS
========================
*/

function initConstants() {
    _aggregateRootCache = Object.create(null);
    _nestedCompositionalOwnerCache = Object.create(null);

    PKSpecialization = {
        Implicit: "implicit",
        Explicit: "explicit",
        ExplicitComposite: "explicit_composite",
        Unknown: "unknown"
    };
    FKSpecialization = {
        Implicit: "implicit",
        Explicit: "explicit",
    };
}

async function showObject(object) {
    await dialogService.info(JSON.stringify(object, null, "  "));
}

async function preselectOrPromptEntity(preselectedDomainClassName) {
    let classes = lookupTypesOf("Class").filter(x =&gt; isAggregateRoot(x) || x.hasStereotype("Repository") || ownerIsAggregateRoot(x));
    if (classes.length == 0) {
        await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
        return;
    }

    let classId = preselectedDomainClassName != null
        ? classes.find(x =&gt; x.getName() === preselectedDomainClassName)?.id
        : await dialogService.lookupFromOptions(classes.map((x)=&gt;({
            id: x.id, 
            name: getFriendlyDisplayNameForClassSelection(x)
            })));
    if (classId == null) {
        await dialogService.error(`No class found with id "${classId}".`);
        return null;
    }

    let foundEntity = lookup(classId);
    return foundEntity;
}

function getFriendlyDisplayNameForClassSelection(element) {
    let found = element.getAssociations("Association").filter(x =&gt; x.isSourceEnd() &amp;&amp; 
            !x.typeReference.isNullable &amp;&amp; 
            !x.typeReference.isCollection &amp;&amp; 
            isAggregateRoot(x.typeReference.getType()))[0]?.typeReference?.getType();
    return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
}

function getServiceFromCurrentContext(entity, packageOrServiceElement) {
    // Auto detect if we're running in the context of a service or package.
    if (packageOrServiceElement.specialization === "Service") {
        return packageOrServiceElement;
    }

    // Must be a package. See if we can find an existing service with the name we expect.
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let expectedServiceName = getServiceName(nestedCompOwner, entity);
    let services = packageOrServiceElement.getChildren("Service").filter(x =&gt; x.name === expectedServiceName);
    if (services.length &gt; 0) {
        return services[0];
    }

    return createElement("Service", expectedServiceName, packageOrServiceElement.id);
}

function getReturnTypeMediatypeProperty(element) {
    return element.getStereotype("Http Settings").getProperty("Return Type Mediatype");
}

function isAggregateRoot(element) {
    if (_aggregateRootCache[element.id]) {
        return _aggregateRootCache[element.id];
    }
    let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
    _aggregateRootCache[element.id] = result;
    return result;
}

function getNestedCompositionalOwner(entity) {
    if (_nestedCompositionalOwnerCache[entity.id]) {
        return _nestedCompositionalOwnerCache[entity.id];
    }

    let result = entity.getAssociations("Association")
        .filter(x =&gt; isAggregateRoot(x.typeReference.getType()) &amp;&amp;
            isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection) [0];
    if(result) {
        _nestedCompositionalOwnerCache[entity.id] = result.typeReference.getType();
    }
    return result;

    function isOwnedBy(association) {
        return association.isSourceEnd() &amp;&amp; 
            !association.typeReference.isNullable &amp;&amp; 
            !association.typeReference.isCollection;
    }
}

function ownerIsAggregateRoot(entity) {
    let result = getNestedCompositionalOwner(entity);
    return result ? true : false;
}

function getEntityFolder(service, entity) {
    let nestedCompOwner = getNestedCompositionalOwner(entity);
    let expectedFolderName = getFolderName(nestedCompOwner, entity);
    var existing = service.getParent().getChildren().find(x =&gt; x.name == expectedFolderName);
    var folder = existing || createElement("Folder", expectedFolderName, service.getParent().id);
    return folder;
}

function hasElementInFolder(entityFolder, expectedElementName) {
    return entityFolder.getChildren().some(x =&gt; x.name == expectedElementName);
}

function setHttpStereotype(element, stereotypeName, props) {
    let stereotype = element.getStereotype(stereotypeName);
    for (let key of Object.keys(props)) {
        stereotype.getProperty(key).setValue(props[key]);
    }
}

function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");

    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }

    return typeNameToIdMap.get("guid");
}

// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getPrimaryKeyDescriptor(entity) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    let pks = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    switch (true) {
        case pks.length == 0:
            return {
                id: null,
                name: getDomainAttributeNameFormat("Id"),
                typeId: getSurrogateKeyType(),
                specialization: PKSpecialization.Implicit,
                compositeKeys: null
            };
        case pks.length == 1:
            let pkAttr = pks[0];
            return {
                id: pkAttr.id,
                name: getDomainAttributeNameFormat(pkAttr.name),
                typeId: pkAttr.typeReference.typeId,
                specialization: PKSpecialization.Explicit,
                compositeKeys: null
            };
        case pks.length &gt; 1:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: PKSpecialization.ExplicitComposite,
                compositeKeys: pks.map(x =&gt; { 
                    return {
                        id: x.id,
                        name: getDomainAttributeNameFormat(x.name),
                        typeId: x.typeReference.typeId
                    }; 
                })
            };
        default:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: PKSpecialization.Unknown,
                compositeKeys: null
            };
    }
}

// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getNestedCompositionalOwnerForeignKeyDescriptor(entity, nestedCompOwner) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    if (!nestedCompOwner) {
        throw new Error("nestedCompOwner not specified");
    }

    let explicitFkAttr = entity.getChildren("Attribute")
        .filter(x =&gt; x.name.toLowerCase().indexOf(nestedCompOwner.name.toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
    
    if (explicitFkAttr) {
        return {
            name: getDomainAttributeNameFormat(explicitFkAttr.name),
            typeId: explicitFkAttr.typeReference.typeId,
            id: explicitFkAttr.id,
            specialization: FKSpecialization.Explicit
        };
    }
    
    return {
        name: getDomainAttributeNameFormat(`${nestedCompOwner.name}Id`),
        typeId: getSurrogateKeyType(),
        id: null,
        specialization: FKSpecialization.Implicit
    };
}

function addPrimaryKeys(commandQuery, operation, entityPkDescr) {
    switch (entityPkDescr.specialization) {
        case PKSpecialization.Implicit:
        case PKSpecialization.Explicit:
            {
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), commandQuery.id);
                primaryKeyDtoField.typeReference.setType(entityPkDescr.typeId);
                if (entityPkDescr.specialization == PKSpecialization.Explicit) {
                    primaryKeyDtoField.setMapping(entityPkDescr.id);
                }

                let operationParamId = createElement("Parameter", getParameterFormat(entityPkDescr.name), operation.id);
                operationParamId.typeReference.setType(primaryKeyDtoField.typeReference.typeId);
                operationParamId.setMapping(primaryKeyDtoField.id);
            }
            break;
        case PKSpecialization.ExplicitComposite:
            for (let key of entityPkDescr.compositeKeys) {
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(key.name), commandQuery.id);
                primaryKeyDtoField.typeReference.setType(key.typeId)
                primaryKeyDtoField.setMapping(key.id);

                let operationParamId = createElement("Parameter", getParameterFormat(key.name), operation.id);
                operationParamId.typeReference.setType(primaryKeyDtoField.typeReference.typeId);
                operationParamId.setMapping(primaryKeyDtoField.id);
            }
            break;
    }
}

function getRoutePath(nestedCompOwnerFkDescr, entity, entityPkDescr) {
    let list = []
    if(nestedCompOwnerFkDescr) {
        list.push(`{${getParameterFormat(nestedCompOwnerFkDescr.name)}}`);
    }
    if(entity) {
        list.push(`${getRoutingFormat(entity.name)}`);
    }
    if (entityPkDescr) {
        switch (entityPkDescr.specialization) {
            case PKSpecialization.Implicit:
            case PKSpecialization.Explicit:
                list.push(`{${getParameterFormat(entityPkDescr.name)}}`);
                break;
            case PKSpecialization.ExplicitComposite:
                list.push(entityPkDescr.compositeKeys.map(x =&gt; `{${getParameterFormat(x.name)}}`))
                break;
        }
    }
    if (list.length == 0) {
        return "";
    }
    return list.join("/");
}

function getDomainAttributeNamingConvention() {
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return application.getSettings(domainSettingsId)
        ?.getField("Attribute Naming Convention")?.value ?? "pascal-case";
}</script>
        </option>
      </scriptOptions>
      <typeOrder />
      <mappingSettings />
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions />
</settings>