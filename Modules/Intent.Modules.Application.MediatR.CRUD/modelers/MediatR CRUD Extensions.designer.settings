<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>46410048-55e6-4cc9-8ee0-dcd0e24a8ee2</id>
  <name>MediatR CRUD Extensions</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions>
    <packageExtension type="Services Package" typeId="df45eaf6-9202-4c25-8dd5-677e9ba1e906">
      <requiredPackages />
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CRUD Service</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="FontAwesome" source="code" />
          <script>// Detect if we're running from the "Execution Script dialogue", in which case we want to manually
// set the element to something:
let defaultDomainClassName = null;
if (element?.id == null) {
    // For testing as if a package was right clicked, substitute with package id:
    // element = { id: "7339add6-c32e-4d95-8e1b-1bbe86ca7f1c" }; // Azure
    // element = { id: "ef5c352b-fc74-4f13-b61b-a970f8360b08" }; // NestJS
    element = { id: "a7ab362f-e8a8-4490-90d5-484b0371d949" };

    // For element, substitute with service's element id:
    // element = lookup("677c6801-e654-45c5-924e-886713db1f5e");

    // When set, the dialog asking to select the class from the domain is skipped:
    defaultDomainClassName = "NewClass";
}

const _aggregateRootCache = Object.create(null);
const _aggregateRootOwnerCache = Object.create(null);

let entity = await preselectOrPromptEntity(defaultDomainClassName);
if (!entity) { return; }
let service = getServiceFromCurrentContext(entity, element);

let entityFolder = getEntityFolder(service, entity);
createCqrsCreateOperation(entityFolder, entity);
let resultCqrsTypeDto = createCqrsResultTypeDTO(entity, entityFolder);
createCqrsFindByIdOperation(entity, entityFolder, resultCqrsTypeDto);
createCqrsFindAllOperation(entity, entityFolder, resultCqrsTypeDto);
createCqrsUpdateOperation(entity, entityFolder);
createCqrsDeleteOperation(entity, entityFolder);

// === FUNCTIONS ===

async function showObject(object) {
    await dialogService.info(JSON.stringify(object, null, "  "));
}

function setHttpStereotype(element, stereotypeName, props) {
    let stereotype = element.getStereotype(stereotypeName);
    for (let key of Object.keys(props)) {
        stereotype.getProperty(key).setValue(props[key]);
    }
}

function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");

    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }

    return typeNameToIdMap.get("guid");
}

function isAggregateRoot(element) {
    if (_aggregateRootCache[element.id]) {
        return _aggregateRootCache[element.id];
    }
    let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
    _aggregateRootCache[element.id] = result;
    return result;
}

function isUserMutable(attributeName) {
    const userImmutableFieldNames = new Set(["created", "createdBy", "id", "updated", "updatedBy"]);
    return !userImmutableFieldNames.has(attributeName.toLowerCase());
}

async function preselectOrPromptEntity(preselectedDomainClassName) {
    let classes = lookupTypesOf("Class").filter(x =&gt; isAggregateRoot(x) || x.hasStereotype("Repository") || ownerIsAggregateRoot(x));
    if (classes.length == 0) {
        await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
        return;
    }

    let classId = preselectedDomainClassName != null
        ? classes.find(x =&gt; x.getName() === preselectedDomainClassName)?.id
        : await dialogService.lookupFromOptions(classes.map((x)=&gt;({
            id: x.id, 
            name: getFriendlyDisplayNameForClassSelection(x)
            })));
    if (classId == null) {
        await dialogService.error(`No class found with id "${classId}".`);
        return null;
    }

    let foundEntity = lookup(classId);
    return foundEntity;
}

function getFriendlyDisplayNameForClassSelection(element) {
    let found = element.getAssociations("Association").filter(x =&gt; x.isSourceEnd() &amp;&amp; 
            !x.typeReference.isNullable &amp;&amp; 
            !x.typeReference.isCollection &amp;&amp; 
            isAggregateRoot(x.typeReference.getType()))[0]?.typeReference?.getType();
    return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
}

function getAggregateRootOwner(entity) {
    if (_aggregateRootOwnerCache[entity.id]) {
        return _aggregateRootOwnerCache[entity.id];
    }
    let result = entity.getAssociations("Association")
        .filter(x =&gt; isAggregateRoot(x.typeReference.getType()) &amp;&amp; 
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection) [0];
    if(result)
    {
        _aggregateRootOwnerCache[entity.id] = result.typeReference.getType();
    }
    return result;
}

function ownerIsAggregateRoot(entity) {
    let result = getAggregateRootOwner(entity);
    return result ? true : false;
}

function getServiceFromCurrentContext(entity, packageOrServiceElement) {
    // Auto detect if we're running in the context of a service or package.
    if (packageOrServiceElement.specialization === "Service") {
        return packageOrServiceElement;
    }

    // Must be a package. See if we can find an existing service with the name we expect.
    let aggrRootOwner = getAggregateRootOwner(entity);
    let expectedServiceName = aggrRootOwner ? `${toPascalCase(aggrRootOwner.name)}${pluralize(toPascalCase(entity.name))}Service` : `${pluralize(toPascalCase(entity.name))}Service`;
    let services = packageOrServiceElement.getChildren("Service").filter(x =&gt; x.name === expectedServiceName);
    if (services.length &gt; 0) {
        return services[0];
    }

    return createElement("Service", expectedServiceName, packageOrServiceElement.id);
}

function getPrimaryKeyTypeId(entity) {
    let pks = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    let pkTypeId;
    switch (true) {
        case pks.length == 0:
            pkTypeId = getSurrogateKeyType();
            break;
        case pks.length == 1:
            pkTypeId = pks[0].typeReference?.typeId ?? getSurrogateKeyType();
            break;
        case pks.length &gt; 1:
            pkTypeId = null;
            break;
    }
    return pkTypeId;
}

function getReturnTypeMediatypeProperty(element) {
    return element.getStereotype("Http Settings").getProperty("Return Type Mediatype");
}

function getEntityFolder(service, entity) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let expectedFolderName = aggrRootOwner ? `${aggrRootOwner.name}${pluralize(entity.name)}` : pluralize(entity.name);
    var existing = service.getParent().getChildren().find(x =&gt; x.name == expectedFolderName);
    var folder = existing || createElement("Folder", expectedFolderName, service.getParent().id);
    return folder;
}

function getAggregateRootId(entity, aggrRootOwner) {
    return entity.getChildren("Attribute").filter(x =&gt; x.name.toLowerCase().indexOf(aggrRootOwner.name.toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
}

function createCqrsCreateOperation(entityFolder, entity) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${entity.name}` : entity.name;
    let expectedCommandName = `Create${baseName}Command`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedCommandName)) {
        let command = createElement("Command", expectedCommandName, entityFolder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);

        let pkTypeId = getPrimaryKeyTypeId(entity);
        command.typeReference.setType(pkTypeId);

        if (aggrRootOwner) {
            let attribute = getAggregateRootId(entity, aggrRootOwner);
            if (attribute) {
                let field = createElement("DTO-Field", attribute.name, command.id);
                field.typeReference.setType(attribute.typeReference.typeId)
                field.setMapping(attribute.id);
            } else {
                let field = createElement("DTO-Field", `${aggrRootOwner.name}Id`, command.id);
                field.typeReference.setType(getSurrogateKeyType())
            }
        }

        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Foreign Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let field = createElement("DTO-Field", attribute.name, command.id);
            field.typeReference.setType(attribute.typeReference.typeId)
            field.setMapping(attribute.id);
        }
        command.collapse();

        let operation = createElement("Operation", "Post", service.id);
        operation.setMapping(command.id);

        setHttpStereotype(operation, "Http Settings", {"Verb": "POST", "Route": ""});

        let param = createElement("Parameter", "command", operation.id);
        param.typeReference.setType(command.id);

        operation.typeReference.setType(pkTypeId);
        if (pkTypeId) {
            getReturnTypeMediatypeProperty(operation).setValue("application/json");
        }

        operation.collapse();
        return;
    }

    let command = entityFolder.getChildren().filter(x =&gt; x.name == expectedCommandName)[0];
    let pkTypeId = getPrimaryKeyTypeId(entity);
    command.typeReference.setType(pkTypeId);
}

function createCqrsResultTypeDTO(entity, entityFolder) {
    let dto = null;
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${entity.name}` : entity.name;
    let expectedDtoName = `${baseName}DTO`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedDtoName)) {
        dto = createElement("DTO", expectedDtoName, entityFolder.id);
        dto.setMapping(entity.id);
        dto.setMetadata("baseName", baseName);

        if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let idField = createElement("DTO-Field", "id", dto.id);
            idField.typeReference.setType(getSurrogateKeyType())
        }

        if (aggrRootOwner) {
            let attribute = getAggregateRootId(entity, aggrRootOwner);
            if (!attribute) {
                let field = createElement("DTO-Field", `${aggrRootOwner.name}Id`, dto.id);
                field.typeReference.setType(getSurrogateKeyType())
            }
        }

        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Partition Key"))) {
            let field = createElement("DTO-Field", attribute.name, dto.id);
            field.typeReference.setType(attribute.typeReference.typeId);
            field.typeReference.setIsNullable(attribute.typeReference.isNullable);
            field.typeReference.setIsCollection(attribute.typeReference.isCollection);
            field.setMapping(attribute.id);
        }
        dto.collapse();
    } else {
        dto = entityFolder.getChildren().filter(x =&gt; x.name == expectedDtoName)[0];
    }
    return dto;
}

function createCqrsFindByIdOperation(entity, entityFolder, resultTypeDto) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${entity.name}` : entity.name;
    let expectedQueryName = `Get${baseName}ByIdQuery`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedQueryName)) {
        let query = createElement("Query", expectedQueryName, entityFolder.id);
        query.typeReference.setType(resultTypeDto.id)
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);

        let operation = createElement("Operation", "Get", service.id);
        operation.setMapping(query.id);

        let aggrRootOwnerParamName = null;
        let aggrRootOwnerIdFieldId = null;
        if (aggrRootOwner) {
            let attribute = getAggregateRootId(entity, aggrRootOwner);
            if (attribute) {
                let field = createElement("DTO-Field", attribute.name, query.id);
                field.typeReference.setType(attribute.typeReference.typeId);
                field.setMapping(attribute.id);
                aggrRootOwnerParamName = toCamelCase(attribute.name);
                aggrRootOwnerIdFieldId = field.id;
            } else {
                let field = createElement("DTO-Field", `${aggrRootOwner.name}Id`, query.id);
                field.typeReference.setType(getSurrogateKeyType());
                aggrRootOwnerParamName = toCamelCase(`${aggrRootOwner.name}Id`);
                aggrRootOwnerIdFieldId = field.id;
            }
        }

        setHttpStereotype(operation, "Http Settings", {"Verb": "GET", "Route": `${(aggrRootOwnerParamName ? `{${aggrRootOwnerParamName}}/` : "")}{id}`});
        if (aggrRootOwnerParamName) {
            let param = createElement("Parameter", aggrRootOwnerParamName, operation.id);
            param.typeReference.setType(getSurrogateKeyType());
            param.setMapping(aggrRootOwnerIdFieldId);
        }

        if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let idField = createElement("DTO-Field", "id", query.id);
            idField.typeReference.setType(getSurrogateKeyType())

            let idParam = createElement("Parameter", "id", operation.id);
            idParam.typeReference.setType(getSurrogateKeyType());
            idParam.setMapping(idField.id);
        } else {
            for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
                let field = createElement("DTO-Field", attribute.name, query.id);
                field.typeReference.setType(attribute.typeReference.typeId)
                field.setMapping(attribute.id);

                let param = createElement("Parameter", field.getName(), operation.id);
                param.typeReference.setType(field.typeReference.typeId);
                param.setMapping(field.id);
            }
        }

        query.collapse();
        operation.collapse();
    }
}

function createCqrsFindAllOperation(entity, entityFolder, resultTypeDto) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${pluralize(entity.name)}` : pluralize(entity.name);
    let expectedQueryName = `Get${baseName}Query`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedQueryName)) {
        let query = createElement("Query", expectedQueryName, entityFolder.id);
        query.typeReference.setType(resultTypeDto.id)
        query.typeReference.setIsCollection(true);
        query.setMetadata("baseName", baseName);

        let aggrRootOwnerParamName = null;
        if (aggrRootOwner) {
            let idField = createElement("DTO-Field", `${aggrRootOwner.name}Id`, query.id);
            idField.typeReference.setType(getSurrogateKeyType());
            aggrRootOwnerParamName = toCamelCase(`${aggrRootOwner.name}Id`);
        }
        
        query.collapse();

        let operation = createElement("Operation", "Get", service.id);
        operation.setMapping(query.id);

        setHttpStereotype(operation, "Http Settings", {"Verb": "GET", "Route": `${(aggrRootOwnerParamName ? `{${aggrRootOwnerParamName}}` : "")}`});
        if (aggrRootOwnerParamName) {
            let param = createElement("Parameter", aggrRootOwnerParamName, operation.id);
            param.typeReference.setType(getSurrogateKeyType());
        }

        operation.collapse();
    }
}

function createCqrsUpdateOperation(entity, entityFolder) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${entity.name}` : entity.name;
    let expectedCommandName = `Update${baseName}Command`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedCommandName)) {
        let command = createElement("Command", expectedCommandName, entityFolder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);

        let operation = createElement("Operation", "Put", service.id);
        operation.setMapping(command.id);

        let aggrRootOwnerParamName = null;
        let aggrRootOwnerIdFieldId = null;
        if (aggrRootOwner) {
            let attribute = getAggregateRootId(entity, aggrRootOwner);
            if (!attribute) {
                let field = createElement("DTO-Field", `${aggrRootOwner.name}Id`, command.id);
                field.typeReference.setType(getSurrogateKeyType())
                aggrRootOwnerParamName = toCamelCase(`${aggrRootOwner.name}Id`);
                aggrRootOwnerIdFieldId = field.id;
            }
        }

        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let field = createElement("DTO-Field", attribute.name, command.id);
            field.typeReference.setType(attribute.typeReference.typeId)
            field.setMapping(attribute.id);
        }

        if (aggrRootOwner) {
            if (!aggrRootOwnerParamName) {
                let attribute = getAggregateRootId(entity, aggrRootOwner);
                if (attribute) {
                    let property = command.getChildren("DTO-Field").filter(x =&gt; x.name.toLowerCase() === attribute.name.toLowerCase())[0];
                    aggrRootOwnerIdFieldId = property?.id;
                    aggrRootOwnerParamName = toCamelCase(attribute.name);
                }
            }

            let param = createElement("Parameter", aggrRootOwnerParamName, operation.id);
            param.typeReference.setType(getSurrogateKeyType());
            param.setMapping(aggrRootOwnerIdFieldId);
        }

        setHttpStereotype(operation, "Http Settings", {"Verb": "PUT", "Route": `${(aggrRootOwnerParamName ? `{${aggrRootOwnerParamName}}/` : "")}{id}`});

        if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let idField = createElement("DTO-Field", "id", command.id);
            idField.typeReference.setType(getSurrogateKeyType())

            let idParam = createElement("Parameter", "id", operation.id);
            idParam.typeReference.setType(getSurrogateKeyType());
            idParam.setMapping(idField.id);
        } else {
            for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
                let field = createElement("DTO-Field", attribute.name, command.id);
                field.typeReference.setType(attribute.typeReference.typeId)
                field.setMapping(attribute.id);

                let param = createElement("Parameter", field.getName(), operation.id);
                param.typeReference.setType(field.typeReference.typeId);
                param.setMapping(field.id);
            }
        }

        let commandParam = createElement("Parameter", "command", operation.id);
        commandParam.typeReference.setType(command.id);

        command.collapse();
        operation.collapse();
    }
}

function createCqrsDeleteOperation(entity, entityFolder) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${entity.name}` : entity.name;
    let expectedCommandName = `Delete${baseName}Command`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedCommandName)) {
        let command = createElement("Command", expectedCommandName, entityFolder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);

        let operation = createElement("Operation", "Delete", service.id);
        operation.setMapping(command.id);

        let aggrRootOwnerParamName = null;
        let aggrRootOwnerIdFieldId = null;
        if (aggrRootOwner) {
            let attribute = getAggregateRootId(entity, aggrRootOwner);
            if (attribute) {
                let field = createElement("DTO-Field", attribute.name, command.id);
                field.typeReference.setType(attribute.typeReference.typeId);
                field.setMapping(attribute.id);
                aggrRootOwnerParamName = toCamelCase(attribute.name);
                aggrRootOwnerIdFieldId = field.id;
            } else {
                let field = createElement("DTO-Field", `${aggrRootOwner.name}Id`, command.id);
                field.typeReference.setType(getSurrogateKeyType());
                aggrRootOwnerParamName = toCamelCase(`${aggrRootOwner.name}Id`);
                aggrRootOwnerIdFieldId = field.id;
            }
        }

        setHttpStereotype(operation, "Http Settings", {"Verb": "DELETE", "Route": `${(aggrRootOwnerParamName ? `{${aggrRootOwnerParamName}}/` : "")}{id}`});
        if (aggrRootOwnerParamName) {
            let param = createElement("Parameter", aggrRootOwnerParamName, operation.id);
            param.typeReference.setType(getSurrogateKeyType());
            param.setMapping(aggrRootOwnerIdFieldId);
        }

        if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let idField = createElement("DTO-Field", "id", command.id);
            idField.typeReference.setType(getSurrogateKeyType());

            let idParam = createElement("Parameter", "id", operation.id);
            idParam.typeReference.setType(getSurrogateKeyType());
            idParam.setMapping(idField.id);
        } else {
            for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
                let field = createElement("DTO-Field", attribute.name, command.id);
                field.typeReference.setType(attribute.typeReference.typeId)
                field.setMapping(attribute.id);

                let param = createElement("Parameter", field.getName(), operation.id);
                param.typeReference.setType(field.typeReference.typeId);
                param.setMapping(field.id);
            }
        }

        command.collapse();
        operation.collapse();
    }
}</script>
        </option>
      </scriptOptions>
      <typeOrder />
    </packageExtension>
  </packageExtensions>
  <elementSettings />
  <elementExtensions>
    <elementExtension type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9">
      <mappingSettings />
      <macros>
        <macro trigger="on-mapped">
          <script>//let element = lookup("29a81107-c71c-45b4-ba7b-982be63277a1")

const projectMapptingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";

let fields = element.getChildren("DTO-Field")
    .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");

fields.forEach(f =&gt; {
    let mappedElement = f.getMapping().getElement();

    let originalVerb = (element.getName().split(/(?=[A-Z])/))[0];

    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName") 
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName =  `${originalVerb}${baseName}`;
    let dto = getOrCreateDTO(dtoName, element.getParent());
    dto.setMetadata("originalVerb", originalVerb);
    dto.setMetadata("baseName", baseName);
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMapptingSettingId);

    ensureDtoFields(mappedElement, dto);
    
    f.typeReference.setType(dto.id);
});

function getOrCreateDTO(elementName, parentElement) {
    const expectedDtoName = `${elementName}DTO`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.name === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }

    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}

function ensureDtoFields(mappedElement, dto) {
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let mappedElementAttributes = domainElement
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;

    for (let attribute of mappedElementAttributes.filter(x =&gt; ! dtoFields.some(y =&gt; x.name === y.name))) {
        if (isCreateMode &amp;&amp; attribute.name?.toLowerCase() === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(attribute, domainElement)) {
            continue;
        }
        if (attribute.hasStereotype("Partition Key")) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.name, dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }

    let explicitPk = dto.getChildren("DTO-Field").filter(x =&gt; x.getMapping()?.getElement()?.hasStereotype("Primary Key"))[0];
    if (!isCreateMode &amp;&amp; !explicitPk) {
        let field = createElement("DTO-Field", "id", dto.id);
        field.typeReference.setType(getSurrogateKeyType());
    }

    if (dtoUpdated) {
        dto.collapse();
    }
}

function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");

    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }

    return typeNameToIdMap.get("guid");
}

function isOwnerForeignKey(attribute, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attribute.name.toLowerCase().indexOf(association.name.toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="DTO" typeId="fee0edca-4aa0-4f77-a524-6bbd84e78734">
      <mappingSettings>
        <mappingSetting id="942eae46-49f1-450e-9274-a92d40ac35fa">
          <name>Project to Domain</name>
          <shortcut>ctrl + shift + p</shortcut>
          <defaultModeler>6ab29b31-27af-4f56-a67c-986d82097d63</defaultModeler>
          <optionsSource>elements-of-type</optionsSource>
          <autoSyncTypeReferences>true</autoSyncTypeReferences>
          <symbol>fa-long-arrow-right</symbol>
          <targetTypeOptions>
            <option specializationType="04e12b51-ed12-42a3-9667-a6aa81bb6d10" displayText="Class" />
          </targetTypeOptions>
          <mapFrom>root</mapFrom>
          <mappings>
            <mapping id="64ebfd83-8720-407a-9308-d6a293873861">
              <criteria specializationType="Class">
                <hasTypeReference p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <isCollection p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <hasChildren p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
              </criteria>
              <mapTo specializationType="DTO" childMappingMode="map-to-child" />
              <behaviour autoSelectChildren="true" />
              <childMappings>
                <mapping id="270e081f-8e9b-46ef-8199-b22860549026">
                  <criteria specializationType="Attribute">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren>false</hasChildren>
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="8841b8bd-7e0f-4903-a3b5-df7447fda037">
                  <criteria specializationType="Association Target End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="90d2281b-0c25-4540-a9f9-3f81ef804f34">
                  <criteria specializationType="Association Source End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="997ed56f-d99d-4c25-8c9e-7cf7f01078f5">
                  <criteria specializationType="Generalization Target End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection>false</isCollection>
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo childMappingMode="traverse" useMappingSettings="64ebfd83-8720-407a-9308-d6a293873861" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
              </childMappings>
            </mapping>
          </mappings>
        </mappingSetting>
      </mappingSettings>
      <macros>
        <macro trigger="on-mapped">
          <script>//let element = lookup("29a81107-c71c-45b4-ba7b-982be63277a1")

const projectMapptingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
const originalDtoMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";

let fields = element.getChildren("DTO-Field")
    .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");

fields.forEach(f =&gt; {
    let mappedElement = f.getMapping().getElement();

    let originalVerb = "";
    if (element.hasMetadata("originalVerb")) {
        originalVerb = element.getMetadata("originalVerb");
        // In the event that the prefix is no longer the same as the
        // originally called verb, then don't propagate this any further
        // as end users might get confused.
        if (element.getName().indexOf(originalVerb) != 0) {
            originalVerb = "";
        }
    }

    let targetMappingSettingId = (!originalVerb || originalVerb === "") 
        ? originalDtoMappingSettingId 
        : projectMapptingSettingId;

    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName") 
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName =  `${originalVerb}${baseName}`;
    let dto = getOrCreateDTO(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), targetMappingSettingId);
    if (originalVerb !== "") {
        dto.setMetadata("originalVerb", originalVerb);
    }
    dto.setMetadata("baseName", baseName);
    ensureDtoFields(mappedElement, dto);
    
    f.typeReference.setType(dto.id);
});

function getOrCreateDTO(elementName, parentElement) {
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.name === `${elementName}DTO`)[0];
    if (existingDto) {
        return existingDto;
    }

    let dto = createElement("DTO", `${elementName}DTO`, parentElement.id);
    return dto;
}

function ensureDtoFields(mappedElement, dto) {
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let mappedElementAttributes = domainElement
        .getChildren("Attribute");
    let isCreateMode = dto.getMetadata("originalVerb")?.toLowerCase()?.startsWith("create") == true;
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; ! dtoFields.some(y =&gt; x.name === y.name))) {
        if (isCreateMode &amp;&amp; attribute.name?.toLowerCase() === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(attribute, domainElement)) {
            continue;
        }
        if (attribute.hasStereotype("Partition Key")) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.name, dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }

    let explicitPk = dto.getChildren("DTO-Field").filter(x =&gt; x.getMapping()?.getElement()?.hasStereotype("Primary Key"))[0];
    if (!isCreateMode &amp;&amp; !explicitPk) {
        let field = createElement("DTO-Field", "id", dto.id);
        field.typeReference.setType(getSurrogateKeyType());
    }

    if (dtoUpdated) {
        dto.collapse();
    }
}

function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");

    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }

    return typeNameToIdMap.get("guid");
}

function isOwnerForeignKey(attribute, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attribute.name.toLowerCase().indexOf(association.name.toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0">
      <mappingSettings />
      <macros>
        <macro trigger="on-mapped">
          <script>//let element = lookup("29a81107-c71c-45b4-ba7b-982be63277a1")

const projectMapptingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";

let fields = element.getChildren("DTO-Field")
    .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");

fields.forEach(f =&gt; {
    let mappedElement = f.getMapping().getElement();

    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName") 
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName =  baseName;
    let dto = getOrCreateDTO(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMapptingSettingId);
    dto.setMetadata("baseName", baseName);

    ensureDtoFields(mappedElement, dto);
    
    f.typeReference.setType(dto.id);
});

function getOrCreateDTO(elementName, parentElement) {
    const expectedQueryName = `${elementName}DTO`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.name === expectedQueryName)[0];
    if (existingDto) {
        return existingDto;
    }

    let dto = createElement("DTO", expectedQueryName, parentElement.id);
    return dto;
}

function ensureDtoFields(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; ! dtoFields.some(y =&gt; x.name === y.name))) {
        if (attribute.hasStereotype("Partition Key")) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.name, dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }

    if (dtoUpdated) {
        dto.collapse();
    }
}</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Service" typeId="b16578a5-27b1-4047-a8df-f0b783d706bd">
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CRUD Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="FontAwesome" source="code" />
          <script>// Detect if we're running from the "Execution Script dialogue", in which case we want to manually
// set the element to something:
let defaultDomainClassName = null;
if (element?.id == null) {
    // For testing as if a package was right clicked, substitute with package id:
    // element = { id: "7339add6-c32e-4d95-8e1b-1bbe86ca7f1c" }; // Azure
    // element = { id: "ef5c352b-fc74-4f13-b61b-a970f8360b08" }; // NestJS
    element = { id: "a7ab362f-e8a8-4490-90d5-484b0371d949" };

    // For element, substitute with service's element id:
    // element = lookup("677c6801-e654-45c5-924e-886713db1f5e");

    // When set, the dialog asking to select the class from the domain is skipped:
    defaultDomainClassName = "NewClass";
}

const _aggregateRootCache = Object.create(null);
const _aggregateRootOwnerCache = Object.create(null);

let entity = await preselectOrPromptEntity(defaultDomainClassName);
if (!entity) { return; }
let service = getServiceFromCurrentContext(entity, element);

let entityFolder = getEntityFolder(service, entity);
createCqrsCreateOperation(entityFolder, entity);
let resultCqrsTypeDto = createCqrsResultTypeDTO(entity, entityFolder);
createCqrsFindByIdOperation(entity, entityFolder, resultCqrsTypeDto);
createCqrsFindAllOperation(entity, entityFolder, resultCqrsTypeDto);
createCqrsUpdateOperation(entity, entityFolder);
createCqrsDeleteOperation(entity, entityFolder);

// === FUNCTIONS ===

async function showObject(object) {
    await dialogService.info(JSON.stringify(object, null, "  "));
}

function setHttpStereotype(element, stereotypeName, props) {
    let stereotype = element.getStereotype(stereotypeName);
    for (let key of Object.keys(props)) {
        stereotype.getProperty(key).setValue(props[key]);
    }
}

function getSurrogateKeyType() {
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", "6b649125-18ea-48fd-a6ba-0bfff0d8f488");
    typeNameToIdMap.set("int", "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74");
    typeNameToIdMap.set("long", "33013006-E404-48C2-AC46-24EF5A5774FD");

    let typeName = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")?.getField("Key Type")?.value ?? "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }

    return typeNameToIdMap.get("guid");
}

function isAggregateRoot(element) {
    if (_aggregateRootCache[element.id]) {
        return _aggregateRootCache[element.id];
    }
    let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
    _aggregateRootCache[element.id] = result;
    return result;
}

function isUserMutable(attributeName) {
    const userImmutableFieldNames = new Set(["created", "createdBy", "id", "updated", "updatedBy"]);
    return !userImmutableFieldNames.has(attributeName.toLowerCase());
}

async function preselectOrPromptEntity(preselectedDomainClassName) {
    let classes = lookupTypesOf("Class").filter(x =&gt; isAggregateRoot(x) || x.hasStereotype("Repository") || ownerIsAggregateRoot(x));
    if (classes.length == 0) {
        await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
        return;
    }

    let classId = preselectedDomainClassName != null
        ? classes.find(x =&gt; x.getName() === preselectedDomainClassName)?.id
        : await dialogService.lookupFromOptions(classes.map((x)=&gt;({
            id: x.id, 
            name: getFriendlyDisplayNameForClassSelection(x)
            })));
    if (classId == null) {
        await dialogService.error(`No class found with id "${classId}".`);
        return null;
    }

    let foundEntity = lookup(classId);
    return foundEntity;
}

function getFriendlyDisplayNameForClassSelection(element) {
    let found = element.getAssociations("Association").filter(x =&gt; x.isSourceEnd() &amp;&amp; 
            !x.typeReference.isNullable &amp;&amp; 
            !x.typeReference.isCollection &amp;&amp; 
            isAggregateRoot(x.typeReference.getType()))[0]?.typeReference?.getType();
    return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
}

function getAggregateRootOwner(entity) {
    if (_aggregateRootOwnerCache[entity.id]) {
        return _aggregateRootOwnerCache[entity.id];
    }
    let result = entity.getAssociations("Association")
        .filter(x =&gt; isAggregateRoot(x.typeReference.getType()) &amp;&amp; 
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection) [0];
    if(result)
    {
        _aggregateRootOwnerCache[entity.id] = result.typeReference.getType();
    }
    return result;
}

function ownerIsAggregateRoot(entity) {
    let result = getAggregateRootOwner(entity);
    return result ? true : false;
}

function getServiceFromCurrentContext(entity, packageOrServiceElement) {
    // Auto detect if we're running in the context of a service or package.
    if (packageOrServiceElement.specialization === "Service") {
        return packageOrServiceElement;
    }

    // Must be a package. See if we can find an existing service with the name we expect.
    let aggrRootOwner = getAggregateRootOwner(entity);
    let expectedServiceName = aggrRootOwner ? `${toPascalCase(aggrRootOwner.name)}${pluralize(toPascalCase(entity.name))}Service` : `${pluralize(toPascalCase(entity.name))}Service`;
    let services = packageOrServiceElement.getChildren("Service").filter(x =&gt; x.name === expectedServiceName);
    if (services.length &gt; 0) {
        return services[0];
    }

    return createElement("Service", expectedServiceName, packageOrServiceElement.id);
}

function getPrimaryKeyTypeId(entity) {
    let pks = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    let pkTypeId;
    switch (true) {
        case pks.length == 0:
            pkTypeId = getSurrogateKeyType();
            break;
        case pks.length == 1:
            pkTypeId = pks[0].typeReference?.typeId ?? getSurrogateKeyType();
            break;
        case pks.length &gt; 1:
            pkTypeId = null;
            break;
    }
    return pkTypeId;
}

function getReturnTypeMediatypeProperty(element) {
    return element.getStereotype("Http Settings").getProperty("Return Type Mediatype");
}

function getEntityFolder(service, entity) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let expectedFolderName = aggrRootOwner ? `${aggrRootOwner.name}${pluralize(entity.name)}` : pluralize(entity.name);
    var existing = service.getParent().getChildren().find(x =&gt; x.name == expectedFolderName);
    var folder = existing || createElement("Folder", expectedFolderName, service.getParent().id);
    return folder;
}

function getAggregateRootId(entity, aggrRootOwner) {
    return entity.getChildren("Attribute").filter(x =&gt; x.name.toLowerCase().indexOf(aggrRootOwner.name.toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
}

function createCqrsCreateOperation(entityFolder, entity) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${entity.name}` : entity.name;
    let expectedCommandName = `Create${baseName}Command`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedCommandName)) {
        let command = createElement("Command", expectedCommandName, entityFolder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);

        let pkTypeId = getPrimaryKeyTypeId(entity);
        command.typeReference.setType(pkTypeId);

        if (aggrRootOwner) {
            let attribute = getAggregateRootId(entity, aggrRootOwner);
            if (attribute) {
                let field = createElement("DTO-Field", attribute.name, command.id);
                field.typeReference.setType(attribute.typeReference.typeId)
                field.setMapping(attribute.id);
            } else {
                let field = createElement("DTO-Field", `${aggrRootOwner.name}Id`, command.id);
                field.typeReference.setType(getSurrogateKeyType())
            }
        }

        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Foreign Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let field = createElement("DTO-Field", attribute.name, command.id);
            field.typeReference.setType(attribute.typeReference.typeId)
            field.setMapping(attribute.id);
        }
        command.collapse();

        let operation = createElement("Operation", "Post", service.id);
        operation.setMapping(command.id);

        setHttpStereotype(operation, "Http Settings", {"Verb": "POST", "Route": ""});

        let param = createElement("Parameter", "command", operation.id);
        param.typeReference.setType(command.id);

        operation.typeReference.setType(pkTypeId);
        if (pkTypeId) {
            getReturnTypeMediatypeProperty(operation).setValue("application/json");
        }

        operation.collapse();
        return;
    }

    let command = entityFolder.getChildren().filter(x =&gt; x.name == expectedCommandName)[0];
    let pkTypeId = getPrimaryKeyTypeId(entity);
    command.typeReference.setType(pkTypeId);
}

function createCqrsResultTypeDTO(entity, entityFolder) {
    let dto = null;
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${entity.name}` : entity.name;
    let expectedDtoName = `${baseName}DTO`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedDtoName)) {
        dto = createElement("DTO", expectedDtoName, entityFolder.id);
        dto.setMapping(entity.id);
        dto.setMetadata("baseName", baseName);

        if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let idField = createElement("DTO-Field", "id", dto.id);
            idField.typeReference.setType(getSurrogateKeyType())
        }

        if (aggrRootOwner) {
            let attribute = getAggregateRootId(entity, aggrRootOwner);
            if (!attribute) {
                let field = createElement("DTO-Field", `${aggrRootOwner.name}Id`, dto.id);
                field.typeReference.setType(getSurrogateKeyType())
            }
        }

        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Partition Key"))) {
            let field = createElement("DTO-Field", attribute.name, dto.id);
            field.typeReference.setType(attribute.typeReference.typeId);
            field.typeReference.setIsNullable(attribute.typeReference.isNullable);
            field.typeReference.setIsCollection(attribute.typeReference.isCollection);
            field.setMapping(attribute.id);
        }
        dto.collapse();
    } else {
        dto = entityFolder.getChildren().filter(x =&gt; x.name == expectedDtoName)[0];
    }
    return dto;
}

function createCqrsFindByIdOperation(entity, entityFolder, resultTypeDto) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${entity.name}` : entity.name;
    let expectedQueryName = `Get${baseName}ByIdQuery`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedQueryName)) {
        let query = createElement("Query", expectedQueryName, entityFolder.id);
        query.typeReference.setType(resultTypeDto.id)
        query.setMapping(entity.id);
        query.setMetadata("baseName", baseName);

        let operation = createElement("Operation", "Get", service.id);
        operation.setMapping(query.id);

        let aggrRootOwnerParamName = null;
        let aggrRootOwnerIdFieldId = null;
        if (aggrRootOwner) {
            let attribute = getAggregateRootId(entity, aggrRootOwner);
            if (attribute) {
                let field = createElement("DTO-Field", attribute.name, query.id);
                field.typeReference.setType(attribute.typeReference.typeId);
                field.setMapping(attribute.id);
                aggrRootOwnerParamName = toCamelCase(attribute.name);
                aggrRootOwnerIdFieldId = field.id;
            } else {
                let field = createElement("DTO-Field", `${aggrRootOwner.name}Id`, query.id);
                field.typeReference.setType(getSurrogateKeyType());
                aggrRootOwnerParamName = toCamelCase(`${aggrRootOwner.name}Id`);
                aggrRootOwnerIdFieldId = field.id;
            }
        }

        setHttpStereotype(operation, "Http Settings", {"Verb": "GET", "Route": `${(aggrRootOwnerParamName ? `{${aggrRootOwnerParamName}}/` : "")}{id}`});
        if (aggrRootOwnerParamName) {
            let param = createElement("Parameter", aggrRootOwnerParamName, operation.id);
            param.typeReference.setType(getSurrogateKeyType());
            param.setMapping(aggrRootOwnerIdFieldId);
        }

        if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let idField = createElement("DTO-Field", "id", query.id);
            idField.typeReference.setType(getSurrogateKeyType())

            let idParam = createElement("Parameter", "id", operation.id);
            idParam.typeReference.setType(getSurrogateKeyType());
            idParam.setMapping(idField.id);
        } else {
            for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
                let field = createElement("DTO-Field", attribute.name, query.id);
                field.typeReference.setType(attribute.typeReference.typeId)
                field.setMapping(attribute.id);

                let param = createElement("Parameter", field.getName(), operation.id);
                param.typeReference.setType(field.typeReference.typeId);
                param.setMapping(field.id);
            }
        }

        query.collapse();
        operation.collapse();
    }
}

function createCqrsFindAllOperation(entity, entityFolder, resultTypeDto) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${pluralize(entity.name)}` : pluralize(entity.name);
    let expectedQueryName = `Get${baseName}Query`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedQueryName)) {
        let query = createElement("Query", expectedQueryName, entityFolder.id);
        query.typeReference.setType(resultTypeDto.id)
        query.typeReference.setIsCollection(true);
        query.setMetadata("baseName", baseName);

        let aggrRootOwnerParamName = null;
        if (aggrRootOwner) {
            let idField = createElement("DTO-Field", `${aggrRootOwner.name}Id`, query.id);
            idField.typeReference.setType(getSurrogateKeyType());
            aggrRootOwnerParamName = toCamelCase(`${aggrRootOwner.name}Id`);
        }
        
        query.collapse();

        let operation = createElement("Operation", "Get", service.id);
        operation.setMapping(query.id);

        setHttpStereotype(operation, "Http Settings", {"Verb": "GET", "Route": `${(aggrRootOwnerParamName ? `{${aggrRootOwnerParamName}}` : "")}`});
        if (aggrRootOwnerParamName) {
            let param = createElement("Parameter", aggrRootOwnerParamName, operation.id);
            param.typeReference.setType(getSurrogateKeyType());
        }

        operation.collapse();
    }
}

function createCqrsUpdateOperation(entity, entityFolder) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${entity.name}` : entity.name;
    let expectedCommandName = `Update${baseName}Command`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedCommandName)) {
        let command = createElement("Command", expectedCommandName, entityFolder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);

        let operation = createElement("Operation", "Put", service.id);
        operation.setMapping(command.id);

        let aggrRootOwnerParamName = null;
        let aggrRootOwnerIdFieldId = null;
        if (aggrRootOwner) {
            let attribute = getAggregateRootId(entity, aggrRootOwner);
            if (!attribute) {
                let field = createElement("DTO-Field", `${aggrRootOwner.name}Id`, command.id);
                field.typeReference.setType(getSurrogateKeyType())
                aggrRootOwnerParamName = toCamelCase(`${aggrRootOwner.name}Id`);
                aggrRootOwnerIdFieldId = field.id;
            }
        }

        for (let attribute of entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let field = createElement("DTO-Field", attribute.name, command.id);
            field.typeReference.setType(attribute.typeReference.typeId)
            field.setMapping(attribute.id);
        }

        if (aggrRootOwner) {
            if (!aggrRootOwnerParamName) {
                let attribute = getAggregateRootId(entity, aggrRootOwner);
                if (attribute) {
                    let property = command.getChildren("DTO-Field").filter(x =&gt; x.name.toLowerCase() === attribute.name.toLowerCase())[0];
                    aggrRootOwnerIdFieldId = property?.id;
                    aggrRootOwnerParamName = toCamelCase(attribute.name);
                }
            }

            let param = createElement("Parameter", aggrRootOwnerParamName, operation.id);
            param.typeReference.setType(getSurrogateKeyType());
            param.setMapping(aggrRootOwnerIdFieldId);
        }

        setHttpStereotype(operation, "Http Settings", {"Verb": "PUT", "Route": `${(aggrRootOwnerParamName ? `{${aggrRootOwnerParamName}}/` : "")}{id}`});

        if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let idField = createElement("DTO-Field", "id", command.id);
            idField.typeReference.setType(getSurrogateKeyType())

            let idParam = createElement("Parameter", "id", operation.id);
            idParam.typeReference.setType(getSurrogateKeyType());
            idParam.setMapping(idField.id);
        } else {
            for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
                let field = createElement("DTO-Field", attribute.name, command.id);
                field.typeReference.setType(attribute.typeReference.typeId)
                field.setMapping(attribute.id);

                let param = createElement("Parameter", field.getName(), operation.id);
                param.typeReference.setType(field.typeReference.typeId);
                param.setMapping(field.id);
            }
        }

        let commandParam = createElement("Parameter", "command", operation.id);
        commandParam.typeReference.setType(command.id);

        command.collapse();
        operation.collapse();
    }
}

function createCqrsDeleteOperation(entity, entityFolder) {
    let aggrRootOwner = getAggregateRootOwner(entity);
    let baseName = aggrRootOwner ? `${aggrRootOwner.name}${entity.name}` : entity.name;
    let expectedCommandName = `Delete${baseName}Command`;
    if (!entityFolder.getChildren().some(x =&gt; x.name == expectedCommandName)) {
        let command = createElement("Command", expectedCommandName, entityFolder.id);
        command.setMapping(entity.id);
        command.setMetadata("baseName", baseName);

        let operation = createElement("Operation", "Delete", service.id);
        operation.setMapping(command.id);

        let aggrRootOwnerParamName = null;
        let aggrRootOwnerIdFieldId = null;
        if (aggrRootOwner) {
            let attribute = getAggregateRootId(entity, aggrRootOwner);
            if (attribute) {
                let field = createElement("DTO-Field", attribute.name, command.id);
                field.typeReference.setType(attribute.typeReference.typeId);
                field.setMapping(attribute.id);
                aggrRootOwnerParamName = toCamelCase(attribute.name);
                aggrRootOwnerIdFieldId = field.id;
            } else {
                let field = createElement("DTO-Field", `${aggrRootOwner.name}Id`, command.id);
                field.typeReference.setType(getSurrogateKeyType());
                aggrRootOwnerParamName = toCamelCase(`${aggrRootOwner.name}Id`);
                aggrRootOwnerIdFieldId = field.id;
            }
        }

        setHttpStereotype(operation, "Http Settings", {"Verb": "DELETE", "Route": `${(aggrRootOwnerParamName ? `{${aggrRootOwnerParamName}}/` : "")}{id}`});
        if (aggrRootOwnerParamName) {
            let param = createElement("Parameter", aggrRootOwnerParamName, operation.id);
            param.typeReference.setType(getSurrogateKeyType());
            param.setMapping(aggrRootOwnerIdFieldId);
        }

        if (entity.getChildren("Attribute").every(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !x.hasStereotype("Partition Key"))) {
            let idField = createElement("DTO-Field", "id", command.id);
            idField.typeReference.setType(getSurrogateKeyType());

            let idParam = createElement("Parameter", "id", operation.id);
            idParam.typeReference.setType(getSurrogateKeyType());
            idParam.setMapping(idField.id);
        } else {
            for (let attribute of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))) {
                let field = createElement("DTO-Field", attribute.name, command.id);
                field.typeReference.setType(attribute.typeReference.typeId)
                field.setMapping(attribute.id);

                let param = createElement("Parameter", field.getName(), operation.id);
                param.typeReference.setType(field.typeReference.typeId);
                param.setMapping(field.id);
            }
        }

        command.collapse();
        operation.collapse();
    }
}</script>
        </option>
      </scriptOptions>
      <typeOrder />
      <mappingSettings />
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions />
</settings>