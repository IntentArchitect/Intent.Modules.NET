// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Intent.Modules.IdentityServer4.UI.Templates.Controllers.ExternalController
{
    using System.Collections.Generic;
    using System.Linq;
    using Intent.Modules.Common;
    using Intent.Modules.Common.Templates;
    using Intent.Modules.Common.CSharp.Templates;
    using Intent.Templates;
    using Intent.Metadata.Models;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "C:\Dev\Intent.Modules.NET\Modules\Intent.Modules.IdentityServer4.UI\Templates\Controllers\ExternalController\ExternalControllerTemplate.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public partial class ExternalControllerTemplate : CSharpTemplateBase<object>
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write("using IdentityModel;\r\nusing IdentityServer4;\r\nusing IdentityServer4.Events;\r\nusin" +
                    "g IdentityServer4.Services;\r\nusing IdentityServer4.Stores;\r\nusing IdentityServer" +
                    "4.Test;\r\nusing Microsoft.AspNetCore.Authentication;\r\nusing Microsoft.AspNetCore." +
                    "Authorization;\r\nusing Microsoft.AspNetCore.Http;\r\nusing Microsoft.AspNetCore.Mvc" +
                    ";\r\nusing Microsoft.Extensions.Logging;\r\nusing System;\r\nusing System.Collections." +
                    "Generic;\r\nusing System.Linq;\r\nusing System.Security.Claims;\r\nusing System.Thread" +
                    "ing.Tasks;\r\n\r\n[assembly: DefaultIntentManaged(Mode.Fully)]\r\n\r\nnamespace Identity" +
                    "ServerHost.Quickstart.UI\r\n{\r\n    [SecurityHeaders]\r\n    [AllowAnonymous]\r\n    pu" +
                    "blic class ExternalController : Controller\r\n    {\r\n        private readonly Test" +
                    "UserStore _users;\r\n        private readonly IIdentityServerInteractionService _i" +
                    "nteraction;\r\n        private readonly IClientStore _clientStore;\r\n        privat" +
                    "e readonly ILogger<ExternalController> _logger;\r\n        private readonly IEvent" +
                    "Service _events;\r\n\r\n        public ExternalController(\r\n            IIdentitySer" +
                    "verInteractionService interaction,\r\n            IClientStore clientStore,\r\n     " +
                    "       IEventService events,\r\n            ILogger<ExternalController> logger,\r\n " +
                    "           TestUserStore users = null)\r\n        {\r\n            _users = users;\r\n" +
                    "\r\n            _interaction = interaction;\r\n            _clientStore = clientStor" +
                    "e;\r\n            _logger = logger;\r\n            _events = events;\r\n        }\r\n\r\n " +
                    "       /// <summary>\r\n        /// initiate roundtrip to external authentication " +
                    "provider\r\n        /// </summary>\r\n        [HttpGet]\r\n        public IActionResul" +
                    "t Challenge(string scheme, string returnUrl)\r\n        {\r\n            if (string." +
                    "IsNullOrEmpty(returnUrl)) returnUrl = \"~/\";\r\n\r\n            // validate returnUrl" +
                    " - either it is a valid OIDC URL or back to a local page\r\n            if (Url.Is" +
                    "LocalUrl(returnUrl) == false && _interaction.IsValidReturnUrl(returnUrl) == fals" +
                    "e)\r\n            {\r\n                // user might have clicked on a malicious lin" +
                    "k - should be logged\r\n                throw new Exception(\"invalid return URL\");" +
                    "\r\n            }\r\n            \r\n            // start challenge and roundtrip the " +
                    "return URL and scheme \r\n            var props = new AuthenticationProperties\r\n  " +
                    "          {\r\n                RedirectUri = Url.Action(nameof(Callback)), \r\n     " +
                    "           Items =\r\n                {\r\n                    { \"returnUrl\", return" +
                    "Url }, \r\n                    { \"scheme\", scheme },\r\n                }\r\n         " +
                    "   };\r\n\r\n            return Challenge(props, scheme);\r\n            \r\n        }\r\n" +
                    "\r\n        /// <summary>\r\n        /// Post processing of external authentication\r" +
                    "\n        /// </summary>\r\n        [HttpGet]\r\n        public async Task<IActionRes" +
                    "ult> Callback()\r\n        {\r\n            // read external identity from the tempo" +
                    "rary cookie\r\n            var result = await HttpContext.AuthenticateAsync(Identi" +
                    "tyServerConstants.ExternalCookieAuthenticationScheme);\r\n            if (result?." +
                    "Succeeded != true)\r\n            {\r\n                throw new Exception(\"External" +
                    " authentication error\");\r\n            }\r\n\r\n            if (_logger.IsEnabled(Log" +
                    "Level.Debug))\r\n            {\r\n                var externalClaims = result.Princi" +
                    "pal.Claims.Select(c => $\"{c.Type}: {c.Value}\");\r\n                _logger.LogDebu" +
                    "g(\"External claims: {@claims}\", externalClaims);\r\n            }\r\n\r\n            /" +
                    "/ lookup our user and external provider info\r\n            var (user, provider, p" +
                    "roviderUserId, claims) = FindUserFromExternalProvider(result);\r\n            if (" +
                    "user == null)\r\n            {\r\n                // this might be where you might i" +
                    "nitiate a custom workflow for user registration\r\n                // in this samp" +
                    "le we don\'t show how that would be done, as our sample implementation\r\n         " +
                    "       // simply auto-provisions new external user\r\n                user = AutoP" +
                    "rovisionUser(provider, providerUserId, claims);\r\n            }\r\n\r\n            //" +
                    " this allows us to collect any additional claims or properties\r\n            // f" +
                    "or the specific protocols used and store them in the local auth cookie.\r\n       " +
                    "     // this is typically used to store data needed for signout from those proto" +
                    "cols.\r\n            var additionalLocalClaims = new List<Claim>();\r\n            v" +
                    "ar localSignInProps = new AuthenticationProperties();\r\n            ProcessLoginC" +
                    "allback(result, additionalLocalClaims, localSignInProps);\r\n            \r\n       " +
                    "     // issue authentication cookie for user\r\n            var isuser = new Ident" +
                    "ityServerUser(user.SubjectId)\r\n            {\r\n                DisplayName = user" +
                    ".Username,\r\n                IdentityProvider = provider,\r\n                Additi" +
                    "onalClaims = additionalLocalClaims\r\n            };\r\n\r\n            await HttpCont" +
                    "ext.SignInAsync(isuser, localSignInProps);\r\n\r\n            // delete temporary co" +
                    "okie used during external authentication\r\n            await HttpContext.SignOutA" +
                    "sync(IdentityServerConstants.ExternalCookieAuthenticationScheme);\r\n\r\n           " +
                    " // retrieve return URL\r\n            var returnUrl = result.Properties.Items[\"re" +
                    "turnUrl\"] ?? \"~/\";\r\n\r\n            // check if external login is in the context o" +
                    "f an OIDC request\r\n            var context = await _interaction.GetAuthorization" +
                    "ContextAsync(returnUrl);\r\n            await _events.RaiseAsync(new UserLoginSucc" +
                    "essEvent(provider, providerUserId, user.SubjectId, user.Username, true, context?" +
                    ".Client.ClientId));\r\n\r\n            if (context != null)\r\n            {\r\n        " +
                    "        if (context.IsNativeClient())\r\n                {\r\n                    //" +
                    " The client is native, so this change in how to\r\n                    // return t" +
                    "he response is for better UX for the end user.\r\n                    return this." +
                    "LoadingPage(\"Redirect\", returnUrl);\r\n                }\r\n            }\r\n\r\n       " +
                    "     return Redirect(returnUrl);\r\n        }\r\n\r\n        private (TestUser user, s" +
                    "tring provider, string providerUserId, IEnumerable<Claim> claims) FindUserFromEx" +
                    "ternalProvider(AuthenticateResult result)\r\n        {\r\n            var externalUs" +
                    "er = result.Principal;\r\n\r\n            // try to determine the unique id of the e" +
                    "xternal user (issued by the provider)\r\n            // the most common claim type" +
                    " for that are the sub claim and the NameIdentifier\r\n            // depending on " +
                    "the external provider, some other claim type might be used\r\n            var user" +
                    "IdClaim = externalUser.FindFirst(JwtClaimTypes.Subject) ??\r\n                    " +
                    "          externalUser.FindFirst(ClaimTypes.NameIdentifier) ??\r\n                " +
                    "              throw new Exception(\"Unknown userid\");\r\n\r\n            // remove th" +
                    "e user id claim so we don\'t include it as an extra claim if/when we provision th" +
                    "e user\r\n            var claims = externalUser.Claims.ToList();\r\n            clai" +
                    "ms.Remove(userIdClaim);\r\n\r\n            var provider = result.Properties.Items[\"s" +
                    "cheme\"];\r\n            var providerUserId = userIdClaim.Value;\r\n\r\n            // " +
                    "find external user\r\n            var user = _users.FindByExternalProvider(provide" +
                    "r, providerUserId);\r\n\r\n            return (user, provider, providerUserId, claim" +
                    "s);\r\n        }\r\n\r\n        private TestUser AutoProvisionUser(string provider, st" +
                    "ring providerUserId, IEnumerable<Claim> claims)\r\n        {\r\n            var user" +
                    " = _users.AutoProvisionUser(provider, providerUserId, claims.ToList());\r\n       " +
                    "     return user;\r\n        }\r\n\r\n        // if the external login is OIDC-based, " +
                    "there are certain things we need to preserve to make logout work\r\n        // thi" +
                    "s will be different for WS-Fed, SAML2p or other protocols\r\n        private void " +
                    "ProcessLoginCallback(AuthenticateResult externalResult, List<Claim> localClaims," +
                    " AuthenticationProperties localSignInProps)\r\n        {\r\n            // if the ex" +
                    "ternal system sent a session id claim, copy it over\r\n            // so we can us" +
                    "e it for single sign-out\r\n            var sid = externalResult.Principal.Claims." +
                    "FirstOrDefault(x => x.Type == JwtClaimTypes.SessionId);\r\n            if (sid != " +
                    "null)\r\n            {\r\n                localClaims.Add(new Claim(JwtClaimTypes.Se" +
                    "ssionId, sid.Value));\r\n            }\r\n\r\n            // if the external provider " +
                    "issued an id_token, we\'ll keep it for signout\r\n            var idToken = externa" +
                    "lResult.Properties.GetTokenValue(\"id_token\");\r\n            if (idToken != null)\r" +
                    "\n            {\r\n                localSignInProps.StoreTokens(new[] { new Authent" +
                    "icationToken { Name = \"id_token\", Value = idToken } });\r\n            }\r\n        " +
                    "}\r\n    }\r\n}");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
}
