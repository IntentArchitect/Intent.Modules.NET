<#@ template language="C#" inherits="CSharpTemplateBase<object>" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Intent.Modules.Common" #>
<#@ import namespace="Intent.Modules.Common.Templates" #>
<#@ import namespace="Intent.Modules.Common.CSharp.Templates" #>
<#@ import namespace="Intent.Templates" #>
<#@ import namespace="Intent.Metadata.Models" #>
using System.Collections;
using System.Collections.Generic;
using System.Linq;

[assembly: DefaultIntentManaged(Mode.Fully)]

namespace <#= Namespace #>
{
    /// <summary>
    /// Provides a wrapper over an <see cref="ICollection{TImplementation}"/> to make it behave as an <see cref="ICollection{TInterface}"/>.  
    /// </summary>
    /// <typeparam name="TInterface">The interface type the collection should be exposed as.</typeparam>
    /// <typeparam name="TImplementation">The actual type of the items in the collection. Must implement <typeparamref name="TInterface"/>.</typeparam>
    public class <#= ClassName #><TInterface, TImplementation> : ICollection<TInterface>
        where TImplementation: TInterface
    {
        private readonly ICollection<TImplementation> _wrappedCollection;

        /// <summary>
        /// Initializes a new instance of the <see cref="CollectionWrapper{TInterface, TImplementation}"/> class.
        /// </summary>
        /// <param name="wrappedCollection">The collection to be wrapped.</param>
        public <#= ClassName #>(ICollection<TImplementation> wrappedCollection)
        {
            _wrappedCollection = wrappedCollection;
        }

        /// <inheritdoc />
        public IEnumerator<TInterface> GetEnumerator()
        {
            return _wrappedCollection.Cast<TInterface>().GetEnumerator();
        }

        /// <inheritdoc />
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// Adds an item to the collection.
        /// </summary>
        /// <param name="item">The item to add to the collection.</param>
        public void Add(TInterface item)
        {
            _wrappedCollection.Add((TImplementation)item!);
        }

        /// <summary>
        /// Removes all items from the collection.
        /// </summary>
        public void Clear()
        {
            _wrappedCollection.Clear();
        }

        /// <summary>
        /// Determines whether the collection contains a specific value.
        /// </summary>
        /// <param name="item">The object to locate in the collection.</param>
        /// <returns>true if <paramref name="item"/> is found in the collection; otherwise, false.</returns>
        public bool Contains(TInterface item)
        {
            return _wrappedCollection.Contains((TImplementation)item!);
        }

        /// <summary>
        /// Copies the elements of the collection to an array, starting at a particular array index.
        /// </summary>
        /// <param name="array">The one-dimensional array that is the destination of the elements copied from collection. The array must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        public void CopyTo(TInterface[] array, int arrayIndex)
        {
            _wrappedCollection.Cast<TInterface>().ToArray().CopyTo(array, arrayIndex);
        }

        /// <summary>
        /// Removes the first occurrence of a specific object from the collection.
        /// </summary>
        /// <param name="item">The object to remove from the collection.</param>
        /// <returns>true if <paramref name="item"/> was successfully removed from the collection; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original collection.</returns>
        public bool Remove(TInterface item)
        {
            return _wrappedCollection.Remove((TImplementation)item!);
        }

        /// <summary>
        /// Gets the number of elements contained in the collection.
        /// </summary>
        public int Count => _wrappedCollection.Count;

        /// <summary>
        /// Gets a value indicating whether the collection is read-only.
        /// </summary>
        public bool IsReadOnly => _wrappedCollection.IsReadOnly;
    }

    /// <summary>
    /// Provides extension methods for <see cref="ICollection{T}"/>.
    /// </summary>
    public static class <#= ClassName #>Extensions
    {
        /// <summary>
        /// Creates a wrapper for a collection to expose it as a different interface.
        /// </summary>
        /// <typeparam name="TInterface">The interface type the collection should be exposed as.</typeparam>
        /// <typeparam name="TImplementation">The actual type of the items in the collection. Must implement <typeparamref name="TInterface"/>.</typeparam>
        /// <param name="collection">The collection to be wrapped.</param>
        /// <returns>An <see cref="ICollection{TInterface}"/> that wraps the provided collection.</returns>
        public static ICollection<TInterface> CreateWrapper<TInterface, TImplementation>(this ICollection<TImplementation> collection) 
            where TImplementation : TInterface
        {
            return new <#= ClassName #><TInterface, TImplementation>(collection);
        }
    }
}