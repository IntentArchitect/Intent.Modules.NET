<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>46410048-55e6-4cc9-8ee0-dcd0e24a8ee2</id>
  <name>MediatR CRUD Extensions</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions>
    <packageExtension type="Services Package" typeId="df45eaf6-9202-4c25-8dd5-677e9ba1e906">
      <requiredPackages />
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CQRS CRUD Operations</text>
          <shortcut>ctrl + shift + u</shortcut>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <script>class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        let keyLen = Object.keys(primaryKeys).length;
        if (Object.keys(primaryKeys).length == 0) {
            return [
                {
                    id: null,
                    name: DomainHelper.getAttributeNameFormat("Id"),
                    typeId: DomainHelper.getSurrogateKeyType(),
                    mapPath: null,
                    isNullable: false,
                    isCollection: false
                }
            ];
        }
        return Object.values(primaryKeys);
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        if (foreignKeys.length &gt; 0) {
            return foreignKeys.map(x =&gt; ({
                name: DomainHelper.getAttributeNameFormat(x.getName()),
                typeId: x.typeReference.typeId,
                id: x.id,
                mapPath: [x.id],
                isCollection: x.typeReference.isCollection,
                isNullable: x.typeReference.isNullable
            }));
        }
        // Implicit FKs:
        return [{
                name: DomainHelper.getAttributeNameFormat(`${owningAggregate.getName()}Id`),
                typeId: Object.values(DomainHelper.getPrimaryKeysMap(owningAggregate))[0].typeId,
                id: null,
                mapPath: null,
                isCollection: false,
                isNullable: false
            }];
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        var _a, _b, _c;
        const commonTypes = {
            guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
            long: "33013006-E404-48C2-AC46-24EF5A5774FD",
            int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
        };
        const javaTypes = {
            long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
            int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
        };
        const typeNameToIdMap = new Map();
        typeNameToIdMap.set("guid", commonTypes.guid);
        typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
        typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
        let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
        if (typeNameToIdMap.has(typeName)) {
            return typeNameToIdMap.get(typeName);
        }
        return typeNameToIdMap.get("guid");
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let primaryKeyDtoField = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                primaryKeyDtoField.typeReference.setType(key.typeId);
                primaryKeyDtoField.setMapping(key.mapPath);
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
}
class ElementManager {
    constructor(command, settings) {
        this.command = command;
        this.settings = settings;
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, typeId) {
        let field = createElement(this.settings.childSpecialization, ServicesHelper.getFieldFormat(name), this.command.id);
        if (typeId) {
            field.typeReference.setType(typeId);
        }
        return field;
    }
    addChildrenFrom(elements) {
        elements.forEach(e =&gt; {
            if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                return;
            }
            let field = this.addChild(ServicesHelper.getFieldFormat(e.name), e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(entity, mappingSettingsId) {
        this.mappedElement = entity;
        this.command.setMapping(entity.id, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const constants = {
    PKSpecialization: {
        Implicit: "implicit",
        Explicit: "explicit",
        ExplicitComposite: "explicit_composite",
        Unknown: "unknown"
    },
    FKSpecialization: {
        Implicit: "implicit",
        Explicit: "explicit",
    }
};
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        let entityPkDescr = getPrimaryKeyDescriptor(domainElement);
        addPrimaryKeys(dto, entityPkDescr);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function addPrimaryKeys(dto, entityPkDescr) {
    switch (entityPkDescr.specialization) {
        case constants.PKSpecialization.Implicit:
        case constants.PKSpecialization.Explicit:
            {
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == getFieldFormat(entityPkDescr.name))) {
                    return;
                }
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
                primaryKeyDtoField.typeReference.setType(entityPkDescr.typeId);
                if (entityPkDescr.specialization == constants.PKSpecialization.Explicit) {
                    primaryKeyDtoField.setMapping(entityPkDescr.mapPath);
                }
            }
            break;
        case constants.PKSpecialization.ExplicitComposite:
            for (let key of entityPkDescr.compositeKeys) {
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == getFieldFormat(key.name))) {
                    continue;
                }
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(key.name), dto.id);
                primaryKeyDtoField.typeReference.setType(key.typeId);
                primaryKeyDtoField.setMapping(key.id);
            }
            break;
    }
}
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.name.toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getPrimaryKeyDescriptor(entity) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    let primaryKeys = getPrimaryKeysWithMapPath(entity);
    let keyLen = Object.keys(primaryKeys).length;
    switch (true) {
        case keyLen == 0:
            return {
                id: null,
                name: getDomainAttributeNameFormat("Id"),
                typeId: getSurrogateKeyType(),
                specialization: constants.PKSpecialization.Implicit,
                compositeKeys: null,
                mapPath: null
            };
        case keyLen == 1:
            let pkAttr = primaryKeys[Object.keys(primaryKeys)[0]];
            return {
                id: pkAttr.id,
                name: getDomainAttributeNameFormat(pkAttr.name),
                typeId: pkAttr.typeId,
                specialization: constants.PKSpecialization.Explicit,
                compositeKeys: null,
                mapPath: pkAttr.mapPath
            };
        case keyLen &gt; 1:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: constants.PKSpecialization.ExplicitComposite,
                compositeKeys: Object.values(primaryKeys).map((v) =&gt; {
                    return {
                        id: v.id,
                        name: getDomainAttributeNameFormat(v.name),
                        typeId: v.typeId,
                        mapPath: v.mapPath
                    };
                }),
                mapPath: null
            };
        default:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: constants.PKSpecialization.Unknown,
                compositeKeys: null,
                mapPath: null
            };
    }
}
;
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return keydict;
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.name === "PartitionKey";
}
/// &lt;reference path="../common/on-map-functions.ts" /&gt;
function onMapCommand(element) {
    var _a, _b, _c, _d;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    var complexTypes = ["Data Contract", "Value Object"];
    let isOperationMappedCommand = element.getMapping() &amp;&amp; element.getMapping().getElement().specialization === "Operation";
    if (isOperationMappedCommand) {
        //Add the entity PK for the repo lookup to invoke the operation
        let entityPkDescr = getPrimaryKeyDescriptor(element);
        addPrimaryKeys(element, entityPkDescr);
        //check for return type
        if (complexTypes.includes((_d = (_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization)) {
            getOrCreateCommandCrudDto(element, element, false, mapFromDomainMappingSettingId);
        }
    }
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");
    fields.forEach(f =&gt; {
        getOrCreateCommandCrudDto(element, f, true, projectMappingSettingId);
    });
    let complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return x.typeReference.getType() == null
            &amp;&amp; (complexTypes.includes((_d = (_c = (_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization));
    });
    complexFields.forEach(cf =&gt; {
        getOrCreateCommandCrudDto(element, cf, false, projectMappingSettingId);
    });
}
function getOrCreateCommandCrudDto(command, dtoField, autoAddPrimaryKey, mappingTypeSettingId) {
    let mappedElement = dtoField.getMapping().getElement();
    if (mappedElement.typeReference == null)
        throw new Error("TypeReference is undefined");
    let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = command.getMetadata("baseName")
        ? `${command.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDto(dtoName, command.getParent());
    dto.setMetadata("originalVerb", originalVerb);
    dto.setMetadata("baseName", baseName);
    dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
    ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
/// &lt;reference path="../common/on-map-functions.ts" /&gt;
function onMapDto(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return x.typeReference.getType() == null &amp;&amp; ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.specialization) === "Association"; });
    fields.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, true);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return x.typeReference.getType() == null
            &amp;&amp; (complexTypes.includes((_d = (_c = (_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, false);
    });
}
function getOrCreateDtoCrudDto(element, dtoField, autoAddPrimaryKey) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const originalDtoMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    let mappedElement = dtoField.getMapping().getElement();
    let originalVerb = "";
    if (element.hasMetadata("originalVerb")) {
        originalVerb = element.getMetadata("originalVerb");
        // In the event that the prefix is no longer the same as the
        // originally called verb, then don't propagate this any further
        // as end users might get confused.
        if (element.getName().indexOf(originalVerb) &lt; 0) {
            originalVerb = "";
        }
    }
    let targetMappingSettingId = (!originalVerb || originalVerb === "")
        ? originalDtoMappingSettingId
        : projectMappingSettingId;
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), targetMappingSettingId);
    if (originalVerb !== "") {
        dto.setMetadata("originalVerb", originalVerb);
    }
    dto.setMetadata("baseName", baseName);
    ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
/// &lt;reference path="../common/on-map-functions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return x.typeReference.getType() == null
            &amp;&amp; (complexTypes.includes((_d = (_c = (_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/command-on-map.ts" /&gt;
/// &lt;reference path="../common/dto-on-map.ts" /&gt;
/// &lt;reference path="../common/query-on-map.ts" /&gt;
// services-cqrs-crud script (see ~/DesignerMacros/src/services-cqrs-crud folder in Intent.Modules)
async function execute() {
    var _a, _b;
    let entity = await DomainHelper.openSelectEntityDialog();
    if (!entity) {
        return;
    }
    let folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
    var existing = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName));
    var folder = existing || createElement("Folder", pluralize(folderName), element.id);
    let dto = createCqrsResultTypeDto(entity, folder);
    createCqrsCreateCommand(entity, folder);
    createCqrsFindByIdQuery(entity, folder, dto);
    createCqrsFindAllQuery(entity, folder, dto);
    const privateSetters = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
    if (privateSetters) {
        let operations = entity.getChildren("Operation").filter(x =&gt; x.typeReference.getType() == null);
        operations.forEach(operation =&gt; {
            createCqrsCallOperationCommand(entity, operation, folder);
        });
    }
    else {
        createCqrsUpdateCommand(entity, folder);
    }
    createCqrsDeleteCommand(entity, folder);
}
;
function createCqrsCreateCommand(entity, folder) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, false);
    let expectedCommandName = `Create${baseName}Command`;
    let primaryKeys = DomainHelper.getPrimaryKeys(entity);
    if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
        let command = folder.getChildren().filter(x =&gt; x.getName() == expectedCommandName)[0];
        command.typeReference.setType(primaryKeys[0].typeId);
        return;
    }
    let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
        childSpecialization: "DTO-Field"
    });
    let entityCtor = entity.getChildren("Class Constructor").find(x =&gt; x.getChildren("Parameter").length &gt; 0);
    if (entityCtor) {
        command.mapToElement(entityCtor, "7c31c459-6229-4f10-bf13-507348cd8828"); // Map to Domain Operation
        command.getElement().setMapping([entity.id, entityCtor.id], "7c31c459-6229-4f10-bf13-507348cd8828"); // Map to Domain Operation
    }
    else {
        command.mapToElement(entity);
    }
    command.getElement().setMetadata("baseName", baseName);
    if (owningAggregate) {
        command.addChildrenFrom(DomainHelper.getForeignKeys(entity, owningAggregate));
    }
    if (primaryKeys[0].typeId) {
        command.setReturnType(primaryKeys[0].typeId);
    }
    if (entityCtor) {
        command.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter"));
    }
    else {
        command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
    }
    onMapCommand(command.getElement());
    command.collapse();
}
function createCqrsFindByIdQuery(entity, folder, resultDto) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, false);
    let expectedQueryName = `Get${baseName}ByIdQuery`;
    if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
        return;
    }
    let query = createElement("Query", expectedQueryName, folder.id);
    query.typeReference.setType(resultDto.id);
    query.setMapping(entity.id);
    query.setMetadata("baseName", baseName);
    if (owningAggregate) {
        let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
        foreignKeys.forEach(fk =&gt; {
            let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
            field.typeReference.setType(fk.typeId);
            if (fk.mapPath) {
                field.setMapping(fk.mapPath);
            }
        });
    }
    let primaryKeys = DomainHelper.getPrimaryKeys(entity);
    ServicesHelper.addDtoFieldsFromDomain(query, primaryKeys);
    onMapQuery(query);
    query.collapse();
}
function createCqrsFindAllQuery(entity, folder, resultDto) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, true);
    let expectedQueryName = `Get${baseName}Query`;
    if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
        return;
    }
    let query = createElement("Query", expectedQueryName, folder.id);
    query.typeReference.setType(resultDto.id);
    query.typeReference.setIsCollection(true);
    query.setMapping(entity.id);
    query.setMetadata("baseName", baseName);
    if (owningAggregate) {
        let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
        foreignKeys.forEach(fk =&gt; {
            let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
            field.typeReference.setType(fk.typeId);
            if (fk.mapPath) {
                field.setMapping(fk.mapPath);
            }
        });
    }
    query.collapse();
}
function createCqrsUpdateCommand(entity, folder) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, false);
    let expectedCommandName = `Update${baseName}Command`;
    if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
        return;
    }
    let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
        childSpecialization: "DTO-Field"
    });
    command.mapToElement(entity);
    command.getElement().setMetadata("baseName", baseName);
    if (owningAggregate) {
        command.addChildrenFrom(DomainHelper.getForeignKeys(entity, owningAggregate));
    }
    command.addChildrenFrom(DomainHelper.getPrimaryKeys(entity));
    command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
    onMapCommand(command.getElement());
    command.collapse();
}
function createCqrsCallOperationCommand(entity, operation, folder) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = owningAggregate ? owningAggregate.getName() : "";
    let expectedCommandName = `${toPascalCase(operation.getName())}${baseName}Command`;
    if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
        return;
    }
    let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
        childSpecialization: "DTO-Field"
    });
    command.mapToElement(operation);
    command.getElement().setMapping([entity.id, operation.id], "7c31c459-6229-4f10-bf13-507348cd8828"); // Map to Domain Operation
    command.getElement().setMetadata("baseName", baseName);
    if (owningAggregate) {
        command.addChildrenFrom(DomainHelper.getForeignKeys(entity, owningAggregate).map(x =&gt; {
            x.mapPath = null;
            return x;
        }));
    }
    command.addChildrenFrom(DomainHelper.getPrimaryKeys(entity).map(x =&gt; {
        x.mapPath = null;
        return x;
    }));
    command.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter"));
    onMapCommand(command.getElement());
    command.collapse();
}
function createCqrsDeleteCommand(entity, folder) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, false);
    let expectedCommandName = `Delete${baseName}Command`;
    if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
        return;
    }
    let command = createElement("Command", expectedCommandName, folder.id);
    command.setMapping(entity.id);
    command.setMetadata("baseName", baseName);
    if (owningAggregate) {
        let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
        foreignKeys.forEach(fk =&gt; {
            let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), command.id);
            field.typeReference.setType(fk.typeId);
            if (fk.mapPath) {
                field.setMapping(fk.mapPath);
            }
        });
    }
    let primaryKeys = DomainHelper.getPrimaryKeys(entity);
    ServicesHelper.addDtoFieldsFromDomain(command, primaryKeys);
    onMapCommand(command);
    command.collapse();
}
function createCqrsResultTypeDto(entity, folder) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, false);
    let expectedDtoName = `${baseName}Dto`;
    let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
    if (existing) {
        return existing;
    }
    let dto = createElement("DTO", expectedDtoName, folder.id);
    dto.setMetadata("baseName", baseName);
    dto.setMapping(entity.id);
    let primaryKeys = DomainHelper.getPrimaryKeys(entity);
    if (owningAggregate) {
        let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
        foreignKeys.forEach(fk =&gt; {
            let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
            field.typeReference.setType(fk.typeId);
            if (fk.mapPath) {
                field.setMapping(fk.mapPath);
            }
        });
    }
    ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
    let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
    for (var attr of attributesWithMapPaths) {
        if (dto.getChildren("DTO-Field").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == attr.id; })) {
            continue;
        }
        let field = createElement("DTO-Field", attr.name, dto.id);
        field.typeReference.setType(attr.typeId);
        field.setMapping(attr.mapPath);
    }
    onMapDto(dto);
    dto.collapse();
    return dto;
}
function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
    let entityName = entityIsMany ? toPascalCase(pluralize(entity.name)) : toPascalCase(entity.name);
    return owningAggregate ? `${toPascalCase(owningAggregate.name)}${entityName}` : entityName;
}
await execute();
</script>
        </option>
      </scriptOptions>
      <typeOrder />
    </packageExtension>
  </packageExtensions>
  <elementSettings />
  <elementExtensions>
    <elementExtension type="Command" typeId="ccf14eb6-3a55-4d81-b5b9-d27311c70cb9">
      <mappingSettings />
      <macros>
        <macro trigger="on-mapped">
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const constants = {
    PKSpecialization: {
        Implicit: "implicit",
        Explicit: "explicit",
        ExplicitComposite: "explicit_composite",
        Unknown: "unknown"
    },
    FKSpecialization: {
        Implicit: "implicit",
        Explicit: "explicit",
    }
};
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        let entityPkDescr = getPrimaryKeyDescriptor(domainElement);
        addPrimaryKeys(dto, entityPkDescr);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function addPrimaryKeys(dto, entityPkDescr) {
    switch (entityPkDescr.specialization) {
        case constants.PKSpecialization.Implicit:
        case constants.PKSpecialization.Explicit:
            {
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == getFieldFormat(entityPkDescr.name))) {
                    return;
                }
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
                primaryKeyDtoField.typeReference.setType(entityPkDescr.typeId);
                if (entityPkDescr.specialization == constants.PKSpecialization.Explicit) {
                    primaryKeyDtoField.setMapping(entityPkDescr.mapPath);
                }
            }
            break;
        case constants.PKSpecialization.ExplicitComposite:
            for (let key of entityPkDescr.compositeKeys) {
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == getFieldFormat(key.name))) {
                    continue;
                }
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(key.name), dto.id);
                primaryKeyDtoField.typeReference.setType(key.typeId);
                primaryKeyDtoField.setMapping(key.id);
            }
            break;
    }
}
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.name.toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getPrimaryKeyDescriptor(entity) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    let primaryKeys = getPrimaryKeysWithMapPath(entity);
    let keyLen = Object.keys(primaryKeys).length;
    switch (true) {
        case keyLen == 0:
            return {
                id: null,
                name: getDomainAttributeNameFormat("Id"),
                typeId: getSurrogateKeyType(),
                specialization: constants.PKSpecialization.Implicit,
                compositeKeys: null,
                mapPath: null
            };
        case keyLen == 1:
            let pkAttr = primaryKeys[Object.keys(primaryKeys)[0]];
            return {
                id: pkAttr.id,
                name: getDomainAttributeNameFormat(pkAttr.name),
                typeId: pkAttr.typeId,
                specialization: constants.PKSpecialization.Explicit,
                compositeKeys: null,
                mapPath: pkAttr.mapPath
            };
        case keyLen &gt; 1:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: constants.PKSpecialization.ExplicitComposite,
                compositeKeys: Object.values(primaryKeys).map((v) =&gt; {
                    return {
                        id: v.id,
                        name: getDomainAttributeNameFormat(v.name),
                        typeId: v.typeId,
                        mapPath: v.mapPath
                    };
                }),
                mapPath: null
            };
        default:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: constants.PKSpecialization.Unknown,
                compositeKeys: null,
                mapPath: null
            };
    }
}
;
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return keydict;
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute")
        .filter(x =&gt; {
        var _a;
        return !x.hasStereotype("Primary Key") &amp;&amp;
            !legacyPartitionKey(x) &amp;&amp;
            (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
    });
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.name === "PartitionKey";
}
/// &lt;reference path="../common/on-map-functions.ts" /&gt;
function onMapCommand(element) {
    var _a, _b, _c, _d;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    var complexTypes = ["Data Contract", "Value Object"];
    let isOperationMappedCommand = element.getMapping() &amp;&amp; element.getMapping().getElement().specialization === "Operation";
    if (isOperationMappedCommand) {
        //Add the entity PK for the repo lookup to invoke the operation
        let entityPkDescr = getPrimaryKeyDescriptor(element);
        addPrimaryKeys(element, entityPkDescr);
        //check for return type
        if (complexTypes.includes((_d = (_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization)) {
            getOrCreateCommandCrudDto(element, element, false, mapFromDomainMappingSettingId);
        }
    }
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");
    fields.forEach(f =&gt; {
        getOrCreateCommandCrudDto(element, f, true, projectMappingSettingId);
    });
    let complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return x.typeReference.getType() == null
            &amp;&amp; (complexTypes.includes((_d = (_c = (_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization));
    });
    complexFields.forEach(cf =&gt; {
        getOrCreateCommandCrudDto(element, cf, false, projectMappingSettingId);
    });
}
function getOrCreateCommandCrudDto(command, dtoField, autoAddPrimaryKey, mappingTypeSettingId) {
    let mappedElement = dtoField.getMapping().getElement();
    if (mappedElement.typeReference == null)
        throw new Error("TypeReference is undefined");
    let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = command.getMetadata("baseName")
        ? `${command.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDto(dtoName, command.getParent());
    dto.setMetadata("originalVerb", originalVerb);
    dto.setMetadata("baseName", baseName);
    dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
    ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
/// &lt;reference path="../common/command-on-map.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.DocumentDB
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/serivces-cqrs-crud/command-on-map/command-on-map.ts
 */
onMapCommand(element);
</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="DTO" typeId="fee0edca-4aa0-4f77-a524-6bbd84e78734">
      <mappingSettings>
        <mappingSetting id="942eae46-49f1-450e-9274-a92d40ac35fa">
          <name>Project to Domain</name>
          <shortcut>ctrl + shift + p</shortcut>
          <defaultModeler>6ab29b31-27af-4f56-a67c-986d82097d63</defaultModeler>
          <optionsSource>elements-of-type</optionsSource>
          <autoSyncTypeReferences>true</autoSyncTypeReferences>
          <symbol>fa-long-arrow-right</symbol>
          <targetTypeOptions>
            <option specializationType="04e12b51-ed12-42a3-9667-a6aa81bb6d10" displayText="Class" />
            <option specializationType="5fe6bb0a-7fc3-42ae-a351-d9188f5b8bc5" displayText="Value Object" />
          </targetTypeOptions>
          <mapFrom>root</mapFrom>
          <mappings>
            <mapping id="64ebfd83-8720-407a-9308-d6a293873861">
              <criteria specializationType="Class">
                <hasTypeReference p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <isCollection p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <hasChildren p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
              </criteria>
              <mapTo specializationType="DTO" childMappingMode="map-to-child" />
              <behaviour autoSelectChildren="true" />
              <childMappings>
                <mapping id="270e081f-8e9b-46ef-8199-b22860549026">
                  <criteria specializationType="Attribute">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren>false</hasChildren>
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="8841b8bd-7e0f-4903-a3b5-df7447fda037">
                  <criteria specializationType="Association Target End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="90d2281b-0c25-4540-a9f9-3f81ef804f34">
                  <criteria specializationType="Association Source End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
                <mapping id="997ed56f-d99d-4c25-8c9e-7cf7f01078f5">
                  <criteria specializationType="Generalization Target End">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection>false</isCollection>
                    <hasChildren p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                  </criteria>
                  <mapTo childMappingMode="traverse" useMappingSettings="64ebfd83-8720-407a-9308-d6a293873861" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
              </childMappings>
            </mapping>
            <mapping id="7a05fe8c-62d8-40e8-b6cf-c1ad30da801e">
              <criteria specializationType="Value Object">
                <hasTypeReference p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <isCollection p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
                <hasChildren p9:nil="true" xmlns:p9="http://www.w3.org/2001/XMLSchema-instance" />
              </criteria>
              <mapTo specializationType="DTO" childMappingMode="map-to-child" />
              <behaviour autoSelectChildren="true" />
              <childMappings>
                <mapping id="88887618-18ad-4240-8051-e95ebccf244a">
                  <criteria specializationType="Attribute">
                    <hasTypeReference>true</hasTypeReference>
                    <isCollection p11:nil="true" xmlns:p11="http://www.w3.org/2001/XMLSchema-instance" />
                    <hasChildren>false</hasChildren>
                  </criteria>
                  <mapTo specializationType="DTO-Field" childMappingMode="map-to-child" />
                  <behaviour autoSelectChildren="false" />
                  <childMappings />
                </mapping>
              </childMappings>
            </mapping>
          </mappings>
        </mappingSetting>
      </mappingSettings>
      <macros>
        <macro trigger="on-mapped">
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const constants = {
    PKSpecialization: {
        Implicit: "implicit",
        Explicit: "explicit",
        ExplicitComposite: "explicit_composite",
        Unknown: "unknown"
    },
    FKSpecialization: {
        Implicit: "implicit",
        Explicit: "explicit",
    }
};
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        let entityPkDescr = getPrimaryKeyDescriptor(domainElement);
        addPrimaryKeys(dto, entityPkDescr);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function addPrimaryKeys(dto, entityPkDescr) {
    switch (entityPkDescr.specialization) {
        case constants.PKSpecialization.Implicit:
        case constants.PKSpecialization.Explicit:
            {
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == getFieldFormat(entityPkDescr.name))) {
                    return;
                }
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
                primaryKeyDtoField.typeReference.setType(entityPkDescr.typeId);
                if (entityPkDescr.specialization == constants.PKSpecialization.Explicit) {
                    primaryKeyDtoField.setMapping(entityPkDescr.mapPath);
                }
            }
            break;
        case constants.PKSpecialization.ExplicitComposite:
            for (let key of entityPkDescr.compositeKeys) {
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == getFieldFormat(key.name))) {
                    continue;
                }
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(key.name), dto.id);
                primaryKeyDtoField.typeReference.setType(key.typeId);
                primaryKeyDtoField.setMapping(key.id);
            }
            break;
    }
}
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.name.toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getPrimaryKeyDescriptor(entity) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    let primaryKeys = getPrimaryKeysWithMapPath(entity);
    let keyLen = Object.keys(primaryKeys).length;
    switch (true) {
        case keyLen == 0:
            return {
                id: null,
                name: getDomainAttributeNameFormat("Id"),
                typeId: getSurrogateKeyType(),
                specialization: constants.PKSpecialization.Implicit,
                compositeKeys: null,
                mapPath: null
            };
        case keyLen == 1:
            let pkAttr = primaryKeys[Object.keys(primaryKeys)[0]];
            return {
                id: pkAttr.id,
                name: getDomainAttributeNameFormat(pkAttr.name),
                typeId: pkAttr.typeId,
                specialization: constants.PKSpecialization.Explicit,
                compositeKeys: null,
                mapPath: pkAttr.mapPath
            };
        case keyLen &gt; 1:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: constants.PKSpecialization.ExplicitComposite,
                compositeKeys: Object.values(primaryKeys).map((v) =&gt; {
                    return {
                        id: v.id,
                        name: getDomainAttributeNameFormat(v.name),
                        typeId: v.typeId,
                        mapPath: v.mapPath
                    };
                }),
                mapPath: null
            };
        default:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: constants.PKSpecialization.Unknown,
                compositeKeys: null,
                mapPath: null
            };
    }
}
;
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return keydict;
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.name === "PartitionKey";
}
/// &lt;reference path="../common/on-map-functions.ts" /&gt;
function onMapDto(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return x.typeReference.getType() == null &amp;&amp; ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.specialization) === "Association"; });
    fields.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, true);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return x.typeReference.getType() == null
            &amp;&amp; (complexTypes.includes((_d = (_c = (_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, false);
    });
}
function getOrCreateDtoCrudDto(element, dtoField, autoAddPrimaryKey) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const originalDtoMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    let mappedElement = dtoField.getMapping().getElement();
    let originalVerb = "";
    if (element.hasMetadata("originalVerb")) {
        originalVerb = element.getMetadata("originalVerb");
        // In the event that the prefix is no longer the same as the
        // originally called verb, then don't propagate this any further
        // as end users might get confused.
        if (element.getName().indexOf(originalVerb) &lt; 0) {
            originalVerb = "";
        }
    }
    let targetMappingSettingId = (!originalVerb || originalVerb === "")
        ? originalDtoMappingSettingId
        : projectMappingSettingId;
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), targetMappingSettingId);
    if (originalVerb !== "") {
        dto.setMetadata("originalVerb", originalVerb);
    }
    dto.setMetadata("baseName", baseName);
    ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
/// &lt;reference path="../common/dto-on-map.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.DocumentDB
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/serivces-cqrs-crud/command-on-map/dto-on-map.ts
 */
onMapDto(element);
</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Folder" typeId="4d95d53a-8855-4f35-aa82-e312643f5c5f">
      <creationOptions />
      <scriptOptions>
        <option>
          <text>Create CQRS CRUD Operations</text>
          <icon type="UrlImagePath" source="data:image/png;base64,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" />
          <script>class DomainHelper {
    static async openSelectEntityDialog(options) {
        let classes = lookupTypesOf("Class").filter(x =&gt; DomainHelper.isAggregateRoot(x) || ((options === null || options === void 0 ? void 0 : options.includeOwnedRelationships) != false &amp;&amp; DomainHelper.ownerIsAggregateRoot(x)) || x.hasStereotype("Repository"));
        if (classes.length == 0) {
            await dialogService.info("No Domain types could be found. Please ensure that you have a reference to the Domain package and that at least one class exists in it.");
            return;
        }
        let classId = await dialogService.lookupFromOptions(classes.map((x) =&gt; ({
            id: x.id,
            name: this.getFriendlyDisplayNameForClassSelection(x)
        })));
        if (classId == null) {
            await dialogService.error(`No class found with id "${classId}".`);
            return null;
        }
        let foundEntity = lookup(classId);
        return foundEntity;
    }
    static getFriendlyDisplayNameForClassSelection(element) {
        let found = DomainHelper.getOwningAggregate(element);
        return !found ? element.getName() : `${element.getName()} (${found.getName()})`;
    }
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getOwningAggregate(entity) {
        var _a;
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        let keyLen = Object.keys(primaryKeys).length;
        if (Object.keys(primaryKeys).length == 0) {
            return [
                {
                    id: null,
                    name: DomainHelper.getAttributeNameFormat("Id"),
                    typeId: DomainHelper.getSurrogateKeyType(),
                    mapPath: null,
                    isNullable: false,
                    isCollection: false
                }
            ];
        }
        return Object.values(primaryKeys);
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        if (foreignKeys.length &gt; 0) {
            return foreignKeys.map(x =&gt; ({
                name: DomainHelper.getAttributeNameFormat(x.getName()),
                typeId: x.typeReference.typeId,
                id: x.id,
                mapPath: [x.id],
                isCollection: x.typeReference.isCollection,
                isNullable: x.typeReference.isNullable
            }));
        }
        // Implicit FKs:
        return [{
                name: DomainHelper.getAttributeNameFormat(`${owningAggregate.getName()}Id`),
                typeId: Object.values(DomainHelper.getPrimaryKeysMap(owningAggregate))[0].typeId,
                id: null,
                mapPath: null,
                isCollection: false,
                isNullable: false
            }];
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        var _a, _b, _c;
        const commonTypes = {
            guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
            long: "33013006-E404-48C2-AC46-24EF5A5774FD",
            int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
        };
        const javaTypes = {
            long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
            int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
        };
        const typeNameToIdMap = new Map();
        typeNameToIdMap.set("guid", commonTypes.guid);
        typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
        typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
        let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
        if (typeNameToIdMap.has(typeName)) {
            return typeNameToIdMap.get(typeName);
        }
        return typeNameToIdMap.get("guid");
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
}
;
class ServicesConstants {
}
ServicesConstants.dtoToEntityMappingId = "01d74d4f-e478-4fde-a2f0-9ea92255f3c5";
ServicesConstants.dtoFromEntityMappingId = "1f747d14-681c-4a20-8c68-34223f41b825";
class ServicesHelper {
    static addDtoFieldsFromDomain(dto, attributes) {
        for (let key of attributes) {
            if (dto &amp;&amp; !dto.getChildren("DTO-Field").some(x =&gt; x.getName() == ServicesHelper.getFieldFormat(key.name))) {
                let primaryKeyDtoField = createElement("DTO-Field", ServicesHelper.getFieldFormat(key.name), dto.id);
                primaryKeyDtoField.typeReference.setType(key.typeId);
                primaryKeyDtoField.setMapping(key.mapPath);
            }
        }
    }
    static getParameterFormat(str) {
        return toCamelCase(str);
    }
    static getRoutingFormat(str) {
        return pluralize(str);
    }
    static getFieldFormat(str) {
        return toPascalCase(str);
    }
}
class ElementManager {
    constructor(command, settings) {
        this.command = command;
        this.settings = settings;
    }
    get id() { return this.command.id; }
    ;
    setReturnType(typeId, isCollection) {
        this.command.typeReference.setType(typeId);
        if (isCollection != null) {
            this.command.typeReference.setIsCollection(isCollection);
        }
        return this;
    }
    addChild(name, typeId) {
        let field = createElement(this.settings.childSpecialization, ServicesHelper.getFieldFormat(name), this.command.id);
        if (typeId) {
            field.typeReference.setType(typeId);
        }
        return field;
    }
    addChildrenFrom(elements) {
        elements.forEach(e =&gt; {
            if (this.command.getChildren(this.settings.childSpecialization).some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == e.id; })) {
                return;
            }
            let field = this.addChild(ServicesHelper.getFieldFormat(e.name), e.typeId);
            field.typeReference.setIsCollection(e.isCollection);
            field.typeReference.setIsNullable(e.isNullable);
            if (this.mappedElement != null &amp;&amp; e.mapPath) {
                field.setMapping(e.mapPath);
            }
        });
        return this;
    }
    mapToElement(entity, mappingSettingsId) {
        this.mappedElement = entity;
        this.command.setMapping(entity.id, mappingSettingsId);
        return this;
    }
    getElement() {
        return this.command;
    }
    collapse() {
        this.command.collapse();
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const constants = {
    PKSpecialization: {
        Implicit: "implicit",
        Explicit: "explicit",
        ExplicitComposite: "explicit_composite",
        Unknown: "unknown"
    },
    FKSpecialization: {
        Implicit: "implicit",
        Explicit: "explicit",
    }
};
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        let entityPkDescr = getPrimaryKeyDescriptor(domainElement);
        addPrimaryKeys(dto, entityPkDescr);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function addPrimaryKeys(dto, entityPkDescr) {
    switch (entityPkDescr.specialization) {
        case constants.PKSpecialization.Implicit:
        case constants.PKSpecialization.Explicit:
            {
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == getFieldFormat(entityPkDescr.name))) {
                    return;
                }
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
                primaryKeyDtoField.typeReference.setType(entityPkDescr.typeId);
                if (entityPkDescr.specialization == constants.PKSpecialization.Explicit) {
                    primaryKeyDtoField.setMapping(entityPkDescr.mapPath);
                }
            }
            break;
        case constants.PKSpecialization.ExplicitComposite:
            for (let key of entityPkDescr.compositeKeys) {
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == getFieldFormat(key.name))) {
                    continue;
                }
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(key.name), dto.id);
                primaryKeyDtoField.typeReference.setType(key.typeId);
                primaryKeyDtoField.setMapping(key.id);
            }
            break;
    }
}
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.name.toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getPrimaryKeyDescriptor(entity) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    let primaryKeys = getPrimaryKeysWithMapPath(entity);
    let keyLen = Object.keys(primaryKeys).length;
    switch (true) {
        case keyLen == 0:
            return {
                id: null,
                name: getDomainAttributeNameFormat("Id"),
                typeId: getSurrogateKeyType(),
                specialization: constants.PKSpecialization.Implicit,
                compositeKeys: null,
                mapPath: null
            };
        case keyLen == 1:
            let pkAttr = primaryKeys[Object.keys(primaryKeys)[0]];
            return {
                id: pkAttr.id,
                name: getDomainAttributeNameFormat(pkAttr.name),
                typeId: pkAttr.typeId,
                specialization: constants.PKSpecialization.Explicit,
                compositeKeys: null,
                mapPath: pkAttr.mapPath
            };
        case keyLen &gt; 1:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: constants.PKSpecialization.ExplicitComposite,
                compositeKeys: Object.values(primaryKeys).map((v) =&gt; {
                    return {
                        id: v.id,
                        name: getDomainAttributeNameFormat(v.name),
                        typeId: v.typeId,
                        mapPath: v.mapPath
                    };
                }),
                mapPath: null
            };
        default:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: constants.PKSpecialization.Unknown,
                compositeKeys: null,
                mapPath: null
            };
    }
}
;
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return keydict;
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.name === "PartitionKey";
}
/// &lt;reference path="../common/on-map-functions.ts" /&gt;
function onMapCommand(element) {
    var _a, _b, _c, _d;
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const mapFromDomainMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    var complexTypes = ["Data Contract", "Value Object"];
    let isOperationMappedCommand = element.getMapping() &amp;&amp; element.getMapping().getElement().specialization === "Operation";
    if (isOperationMappedCommand) {
        //Add the entity PK for the repo lookup to invoke the operation
        let entityPkDescr = getPrimaryKeyDescriptor(element);
        addPrimaryKeys(element, entityPkDescr);
        //check for return type
        if (complexTypes.includes((_d = (_c = (_b = (_a = element.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization)) {
            getOrCreateCommandCrudDto(element, element, false, mapFromDomainMappingSettingId);
        }
    }
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");
    fields.forEach(f =&gt; {
        getOrCreateCommandCrudDto(element, f, true, projectMappingSettingId);
    });
    let complexFields = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return x.typeReference.getType() == null
            &amp;&amp; (complexTypes.includes((_d = (_c = (_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization));
    });
    complexFields.forEach(cf =&gt; {
        getOrCreateCommandCrudDto(element, cf, false, projectMappingSettingId);
    });
}
function getOrCreateCommandCrudDto(command, dtoField, autoAddPrimaryKey, mappingTypeSettingId) {
    let mappedElement = dtoField.getMapping().getElement();
    if (mappedElement.typeReference == null)
        throw new Error("TypeReference is undefined");
    let originalVerb = (command.getName().split(/(?=[A-Z])/))[0];
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = command.getMetadata("baseName")
        ? `${command.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDto(dtoName, command.getParent());
    dto.setMetadata("originalVerb", originalVerb);
    dto.setMetadata("baseName", baseName);
    dto.setMapping(mappedElement.typeReference.getTypeId(), mappingTypeSettingId);
    ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
/// &lt;reference path="../common/on-map-functions.ts" /&gt;
function onMapDto(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; { var _a, _b; return x.typeReference.getType() == null &amp;&amp; ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.specialization) === "Association"; });
    fields.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, true);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return x.typeReference.getType() == null
            &amp;&amp; (complexTypes.includes((_d = (_c = (_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateDtoCrudDto(element, f, false);
    });
}
function getOrCreateDtoCrudDto(element, dtoField, autoAddPrimaryKey) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    const originalDtoMappingSettingId = "1f747d14-681c-4a20-8c68-34223f41b825";
    let mappedElement = dtoField.getMapping().getElement();
    let originalVerb = "";
    if (element.hasMetadata("originalVerb")) {
        originalVerb = element.getMetadata("originalVerb");
        // In the event that the prefix is no longer the same as the
        // originally called verb, then don't propagate this any further
        // as end users might get confused.
        if (element.getName().indexOf(originalVerb) &lt; 0) {
            originalVerb = "";
        }
    }
    let targetMappingSettingId = (!originalVerb || originalVerb === "")
        ? originalDtoMappingSettingId
        : projectMappingSettingId;
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : domainName;
    let dtoName = `${originalVerb}${baseName}`;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), targetMappingSettingId);
    if (originalVerb !== "") {
        dto.setMetadata("originalVerb", originalVerb);
    }
    dto.setMetadata("baseName", baseName);
    ensureDtoFields(autoAddPrimaryKey, mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
/// &lt;reference path="../common/on-map-functions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return x.typeReference.getType() == null
            &amp;&amp; (complexTypes.includes((_d = (_c = (_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
/// &lt;reference path="../../common/servicesHelper.ts" /&gt;
/// &lt;reference path="../common/command-on-map.ts" /&gt;
/// &lt;reference path="../common/dto-on-map.ts" /&gt;
/// &lt;reference path="../common/query-on-map.ts" /&gt;
// services-cqrs-crud script (see ~/DesignerMacros/src/services-cqrs-crud folder in Intent.Modules)
async function execute() {
    var _a, _b;
    let entity = await DomainHelper.openSelectEntityDialog();
    if (!entity) {
        return;
    }
    let folderName = pluralize(DomainHelper.ownerIsAggregateRoot(entity) ? DomainHelper.getOwningAggregate(entity).getName() : entity.getName());
    var existing = element.getChildren().find(x =&gt; x.getName() == pluralize(folderName));
    var folder = existing || createElement("Folder", pluralize(folderName), element.id);
    let dto = createCqrsResultTypeDto(entity, folder);
    createCqrsCreateCommand(entity, folder);
    createCqrsFindByIdQuery(entity, folder, dto);
    createCqrsFindAllQuery(entity, folder, dto);
    const privateSetters = ((_b = (_a = application.getSettings("c4d1e35c-7c0d-4926-afe0-18f17563ce17")) === null || _a === void 0 ? void 0 : _a.getField("0cf704e1-9a61-499a-bb91-b20717e334f5")) === null || _b === void 0 ? void 0 : _b.value) == "true";
    if (privateSetters) {
        let operations = entity.getChildren("Operation").filter(x =&gt; x.typeReference.getType() == null);
        operations.forEach(operation =&gt; {
            createCqrsCallOperationCommand(entity, operation, folder);
        });
    }
    else {
        createCqrsUpdateCommand(entity, folder);
    }
    createCqrsDeleteCommand(entity, folder);
}
;
function createCqrsCreateCommand(entity, folder) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, false);
    let expectedCommandName = `Create${baseName}Command`;
    let primaryKeys = DomainHelper.getPrimaryKeys(entity);
    if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
        let command = folder.getChildren().filter(x =&gt; x.getName() == expectedCommandName)[0];
        command.typeReference.setType(primaryKeys[0].typeId);
        return;
    }
    let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
        childSpecialization: "DTO-Field"
    });
    let entityCtor = entity.getChildren("Class Constructor").find(x =&gt; x.getChildren("Parameter").length &gt; 0);
    if (entityCtor) {
        command.mapToElement(entityCtor, "7c31c459-6229-4f10-bf13-507348cd8828"); // Map to Domain Operation
        command.getElement().setMapping([entity.id, entityCtor.id], "7c31c459-6229-4f10-bf13-507348cd8828"); // Map to Domain Operation
    }
    else {
        command.mapToElement(entity);
    }
    command.getElement().setMetadata("baseName", baseName);
    if (owningAggregate) {
        command.addChildrenFrom(DomainHelper.getForeignKeys(entity, owningAggregate));
    }
    if (primaryKeys[0].typeId) {
        command.setReturnType(primaryKeys[0].typeId);
    }
    if (entityCtor) {
        command.addChildrenFrom(DomainHelper.getChildrenOfType(entityCtor, "Parameter"));
    }
    else {
        command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
    }
    onMapCommand(command.getElement());
    command.collapse();
}
function createCqrsFindByIdQuery(entity, folder, resultDto) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, false);
    let expectedQueryName = `Get${baseName}ByIdQuery`;
    if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
        return;
    }
    let query = createElement("Query", expectedQueryName, folder.id);
    query.typeReference.setType(resultDto.id);
    query.setMapping(entity.id);
    query.setMetadata("baseName", baseName);
    if (owningAggregate) {
        let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
        foreignKeys.forEach(fk =&gt; {
            let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
            field.typeReference.setType(fk.typeId);
            if (fk.mapPath) {
                field.setMapping(fk.mapPath);
            }
        });
    }
    let primaryKeys = DomainHelper.getPrimaryKeys(entity);
    ServicesHelper.addDtoFieldsFromDomain(query, primaryKeys);
    onMapQuery(query);
    query.collapse();
}
function createCqrsFindAllQuery(entity, folder, resultDto) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, true);
    let expectedQueryName = `Get${baseName}Query`;
    if (folder.getChildren().some(x =&gt; x.getName() == expectedQueryName)) {
        return;
    }
    let query = createElement("Query", expectedQueryName, folder.id);
    query.typeReference.setType(resultDto.id);
    query.typeReference.setIsCollection(true);
    query.setMapping(entity.id);
    query.setMetadata("baseName", baseName);
    if (owningAggregate) {
        let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
        foreignKeys.forEach(fk =&gt; {
            let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), query.id);
            field.typeReference.setType(fk.typeId);
            if (fk.mapPath) {
                field.setMapping(fk.mapPath);
            }
        });
    }
    query.collapse();
}
function createCqrsUpdateCommand(entity, folder) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, false);
    let expectedCommandName = `Update${baseName}Command`;
    if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
        return;
    }
    let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
        childSpecialization: "DTO-Field"
    });
    command.mapToElement(entity);
    command.getElement().setMetadata("baseName", baseName);
    if (owningAggregate) {
        command.addChildrenFrom(DomainHelper.getForeignKeys(entity, owningAggregate));
    }
    command.addChildrenFrom(DomainHelper.getPrimaryKeys(entity));
    command.addChildrenFrom(DomainHelper.getAttributesWithMapPath(entity));
    onMapCommand(command.getElement());
    command.collapse();
}
function createCqrsCallOperationCommand(entity, operation, folder) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = owningAggregate ? owningAggregate.getName() : "";
    let expectedCommandName = `${toPascalCase(operation.getName())}${baseName}Command`;
    if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
        return;
    }
    let command = new ElementManager(createElement("Command", expectedCommandName, folder.id), {
        childSpecialization: "DTO-Field"
    });
    command.mapToElement(operation);
    command.getElement().setMapping([entity.id, operation.id], "7c31c459-6229-4f10-bf13-507348cd8828"); // Map to Domain Operation
    command.getElement().setMetadata("baseName", baseName);
    if (owningAggregate) {
        command.addChildrenFrom(DomainHelper.getForeignKeys(entity, owningAggregate).map(x =&gt; {
            x.mapPath = null;
            return x;
        }));
    }
    command.addChildrenFrom(DomainHelper.getPrimaryKeys(entity).map(x =&gt; {
        x.mapPath = null;
        return x;
    }));
    command.addChildrenFrom(DomainHelper.getChildrenOfType(operation, "Parameter"));
    command.collapse();
}
function createCqrsDeleteCommand(entity, folder) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, false);
    let expectedCommandName = `Delete${baseName}Command`;
    if (folder.getChildren().some(x =&gt; x.getName() == expectedCommandName)) {
        return;
    }
    let command = createElement("Command", expectedCommandName, folder.id);
    command.setMapping(entity.id);
    command.setMetadata("baseName", baseName);
    if (owningAggregate) {
        let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
        foreignKeys.forEach(fk =&gt; {
            let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), command.id);
            field.typeReference.setType(fk.typeId);
            if (fk.mapPath) {
                field.setMapping(fk.mapPath);
            }
        });
    }
    let primaryKeys = DomainHelper.getPrimaryKeys(entity);
    ServicesHelper.addDtoFieldsFromDomain(command, primaryKeys);
    onMapCommand(command);
    command.collapse();
}
function createCqrsResultTypeDto(entity, folder) {
    let owningAggregate = DomainHelper.getOwningAggregate(entity);
    let baseName = getBaseNameForElement(owningAggregate, entity, false);
    let expectedDtoName = `${baseName}Dto`;
    let existing = folder.getChildren().find(x =&gt; x.getName() == expectedDtoName);
    if (existing) {
        return existing;
    }
    let dto = createElement("DTO", expectedDtoName, folder.id);
    dto.setMetadata("baseName", baseName);
    dto.setMapping(entity.id);
    let primaryKeys = DomainHelper.getPrimaryKeys(entity);
    if (owningAggregate) {
        let foreignKeys = DomainHelper.getForeignKeys(entity, owningAggregate);
        foreignKeys.forEach(fk =&gt; {
            let field = createElement("DTO-Field", ServicesHelper.getFieldFormat(fk.name), dto.id);
            field.typeReference.setType(fk.typeId);
            if (fk.mapPath) {
                field.setMapping(fk.mapPath);
            }
        });
    }
    ServicesHelper.addDtoFieldsFromDomain(dto, primaryKeys);
    let attributesWithMapPaths = DomainHelper.getAttributesWithMapPath(entity);
    for (var attr of attributesWithMapPaths) {
        if (dto.getChildren("DTO-Field").some(x =&gt; { var _a, _b; return ((_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.id) == attr.id; })) {
            continue;
        }
        let field = createElement("DTO-Field", attr.name, dto.id);
        field.typeReference.setType(attr.typeId);
        field.setMapping(attr.mapPath);
    }
    onMapDto(dto);
    dto.collapse();
    return dto;
}
function getBaseNameForElement(owningAggregate, entity, entityIsMany) {
    let entityName = entityIsMany ? toPascalCase(pluralize(entity.name)) : toPascalCase(entity.name);
    return owningAggregate ? `${toPascalCase(owningAggregate.name)}${entityName}` : entityName;
}
await execute();
</script>
        </option>
      </scriptOptions>
      <typeOrder />
      <mappingSettings />
    </elementExtension>
    <elementExtension type="Query" typeId="e71b0662-e29d-4db2-868b-8a12464b25d0">
      <mappingSettings />
      <macros>
        <macro trigger="on-mapped">
          <script>/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
const constants = {
    PKSpecialization: {
        Implicit: "implicit",
        Explicit: "explicit",
        ExplicitComposite: "explicit_composite",
        Unknown: "unknown"
    },
    FKSpecialization: {
        Implicit: "implicit",
        Explicit: "explicit",
    }
};
function getFieldFormat(str) {
    return toPascalCase(str);
}
function getDomainAttributeNameFormat(str) {
    let convention = getDomainAttributeNamingConvention();
    switch (convention) {
        case "pascal-case":
            return toPascalCase(str);
        case "camel-case":
            return toCamelCase(str);
    }
    return str;
}
function getOrCreateDto(elementName, parentElement) {
    const expectedDtoName = `${elementName}Dto`;
    let existingDto = parentElement.getChildren("DTO").filter(x =&gt; x.getName() === expectedDtoName)[0];
    if (existingDto) {
        return existingDto;
    }
    let dto = createElement("DTO", expectedDtoName, parentElement.id);
    return dto;
}
function ensureDtoFields(autoAddPrimaryKey, mappedElement, dto) {
    var _a, _b, _c;
    let dtoUpdated = false;
    let domainElement = mappedElement
        .typeReference
        .getType();
    let attributesWithMapPaths = getAttributesWithMapPath(domainElement);
    let isCreateMode = ((_b = (_a = dto.getMetadata("originalVerb")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.startsWith("create")) == true;
    for (var keyName of Object.keys(attributesWithMapPaths)) {
        let entry = attributesWithMapPaths[keyName];
        if (isCreateMode &amp;&amp; ((_c = entry.name) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "id") {
            continue;
        }
        if (isCreateMode &amp;&amp; isOwnerForeignKey(entry.name, domainElement)) {
            continue;
        }
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == entry.name)) {
            continue;
        }
        let field = createElement("DTO-Field", entry.name, dto.id);
        field.typeReference.setType(entry.typeId);
        field.typeReference.setIsNullable(entry.isNullable);
        field.typeReference.setIsCollection(entry.isCollection);
        field.setMapping(entry.mapPath);
        dtoUpdated = true;
    }
    if (autoAddPrimaryKey &amp;&amp; !isCreateMode) {
        let entityPkDescr = getPrimaryKeyDescriptor(domainElement);
        addPrimaryKeys(dto, entityPkDescr);
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
function addPrimaryKeys(dto, entityPkDescr) {
    switch (entityPkDescr.specialization) {
        case constants.PKSpecialization.Implicit:
        case constants.PKSpecialization.Explicit:
            {
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == getFieldFormat(entityPkDescr.name))) {
                    return;
                }
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(entityPkDescr.name), dto.id);
                primaryKeyDtoField.typeReference.setType(entityPkDescr.typeId);
                if (entityPkDescr.specialization == constants.PKSpecialization.Explicit) {
                    primaryKeyDtoField.setMapping(entityPkDescr.mapPath);
                }
            }
            break;
        case constants.PKSpecialization.ExplicitComposite:
            for (let key of entityPkDescr.compositeKeys) {
                if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == getFieldFormat(key.name))) {
                    continue;
                }
                let primaryKeyDtoField = createElement("DTO-Field", getFieldFormat(key.name), dto.id);
                primaryKeyDtoField.typeReference.setType(key.typeId);
                primaryKeyDtoField.setMapping(key.id);
            }
            break;
    }
}
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
function isOwnerForeignKey(attributeName, domainElement) {
    for (let association of domainElement.getAssociations().filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable)) {
        if (attributeName.toLowerCase().indexOf(association.name.toLowerCase()) &gt;= 0) {
            return true;
        }
    }
    return false;
}
// Returns a dictionary instead of element to help deal with explicit vs implicit keys
function getPrimaryKeyDescriptor(entity) {
    if (!entity) {
        throw new Error("entity not specified");
    }
    let primaryKeys = getPrimaryKeysWithMapPath(entity);
    let keyLen = Object.keys(primaryKeys).length;
    switch (true) {
        case keyLen == 0:
            return {
                id: null,
                name: getDomainAttributeNameFormat("Id"),
                typeId: getSurrogateKeyType(),
                specialization: constants.PKSpecialization.Implicit,
                compositeKeys: null,
                mapPath: null
            };
        case keyLen == 1:
            let pkAttr = primaryKeys[Object.keys(primaryKeys)[0]];
            return {
                id: pkAttr.id,
                name: getDomainAttributeNameFormat(pkAttr.name),
                typeId: pkAttr.typeId,
                specialization: constants.PKSpecialization.Explicit,
                compositeKeys: null,
                mapPath: pkAttr.mapPath
            };
        case keyLen &gt; 1:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: constants.PKSpecialization.ExplicitComposite,
                compositeKeys: Object.values(primaryKeys).map((v) =&gt; {
                    return {
                        id: v.id,
                        name: getDomainAttributeNameFormat(v.name),
                        typeId: v.typeId,
                        mapPath: v.mapPath
                    };
                }),
                mapPath: null
            };
        default:
            return {
                id: null,
                name: null,
                typeId: null,
                specialization: constants.PKSpecialization.Unknown,
                compositeKeys: null,
                mapPath: null
            };
    }
}
;
function getPrimaryKeysWithMapPath(entity) {
    let keydict = Object.create(null);
    let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
    keys.forEach(key =&gt; keydict[key.id] = {
        id: key.id,
        name: key.getName(),
        typeId: key.typeReference.typeId,
        mapPath: [key.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
    return keydict;
    function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        baseKeys.forEach(key =&gt; {
            keydict[key.id] = {
                id: key.id,
                name: key.getName(),
                typeId: key.typeReference.typeId,
                mapPath: generalizationStack.concat([key.id]),
                isNullable: key.typeReference.isNullable,
                isCollection: key.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
    }
}
function getAttributesWithMapPath(entity) {
    let attrDict = Object.create(null);
    let attributes = entity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
    attributes.forEach(attr =&gt; attrDict[attr.id] = {
        id: attr.id,
        name: attr.getName(),
        typeId: attr.typeReference.typeId,
        mapPath: [attr.id],
        isNullable: false,
        isCollection: false
    });
    traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
    return attrDict;
    function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
        if (!curEntity) {
            return;
        }
        let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
        if (generalizations.length == 0) {
            return;
        }
        let generalization = generalizations[0];
        generalizationStack.push(generalization.id);
        let nextEntity = generalization.typeReference.getType();
        let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !legacyPartitionKey(x));
        baseKeys.forEach(attr =&gt; {
            attrDict[attr.id] = {
                id: attr.id,
                name: attr.getName(),
                typeId: attr.typeReference.typeId,
                mapPath: generalizationStack.concat([attr.id]),
                isNullable: attr.typeReference.isNullable,
                isCollection: attr.typeReference.isCollection
            };
        });
        traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
    }
}
function getDomainAttributeNamingConvention() {
    var _a, _b, _c;
    const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
    return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
}
// Just in case someone still uses this convention. Used to filter out those attributes when mapping
// to domain entities that are within a Cosmos DB paradigm.
function legacyPartitionKey(attribute) {
    return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.name === "PartitionKey";
}
/// &lt;reference path="../common/on-map-functions.ts" /&gt;
function onMapQuery(element) {
    var complexTypes = ["Data Contract", "Value Object"];
    let fields = element.getChildren("DTO-Field")
        .filter(x =&gt; x.typeReference.getType() == null &amp;&amp; x.getMapping().getElement().specialization === "Association");
    fields.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
    let complexAttributes = element.getChildren("DTO-Field")
        .filter(x =&gt; {
        var _a, _b, _c, _d;
        return x.typeReference.getType() == null
            &amp;&amp; (complexTypes.includes((_d = (_c = (_b = (_a = x.getMapping()) === null || _a === void 0 ? void 0 : _a.getElement()) === null || _b === void 0 ? void 0 : _b.typeReference) === null || _c === void 0 ? void 0 : _c.getType()) === null || _d === void 0 ? void 0 : _d.specialization));
    });
    complexAttributes.forEach(f =&gt; {
        getOrCreateQueryCrudDto(element, f);
    });
}
function getOrCreateQueryCrudDto(element, dtoField) {
    const projectMappingSettingId = "942eae46-49f1-450e-9274-a92d40ac35fa";
    let mappedElement = dtoField.getMapping().getElement();
    let domainName = mappedElement.typeReference.getType().getName();
    let baseName = element.getMetadata("baseName")
        ? `${element.getMetadata("baseName")}${domainName}`
        : `${domainName}`;
    let dtoName = baseName;
    let dto = getOrCreateDto(dtoName, element.getParent());
    dto.setMapping(mappedElement.typeReference.getTypeId(), projectMappingSettingId);
    dto.setMetadata("baseName", baseName);
    ensureDtoFieldsQuery(mappedElement, dto);
    dtoField.typeReference.setType(dto.id);
}
function ensureDtoFieldsQuery(mappedElement, dto) {
    let dtoUpdated = false;
    let mappedElementAttributes = mappedElement
        .typeReference
        .getType()
        .getChildren("Attribute");
    let dtoFields = dto.getChildren("DTO-Field");
    for (let attribute of mappedElementAttributes.filter(x =&gt; !dtoFields.some(y =&gt; x.getName() === y.getName()))) {
        if (dto.getChildren("DTO-Field").some(x =&gt; x.getName() == attribute.getName())) {
            continue;
        }
        let field = createElement("DTO-Field", attribute.getName(), dto.id);
        field.typeReference.setType(attribute.typeReference.typeId);
        field.typeReference.setIsNullable(attribute.typeReference.isNullable);
        field.typeReference.setIsCollection(attribute.typeReference.isCollection);
        field.setMapping(attribute.id);
        dtoUpdated = true;
    }
    if (dtoUpdated) {
        dto.collapse();
    }
}
/// &lt;reference path="../common/query-on-map.ts" /&gt;
/**
 * Used by Intent.Modules\Modules\Intent.Modules.Metadata.DocumentDB
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/master/DesignerMacros/src/serivces-cqrs-crud/query-on-map/query-on-map.ts
 */
onMapQuery(element);
</script>
        </macro>
      </macros>
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions />
</settings>