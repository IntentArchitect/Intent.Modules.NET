<?xml version="1.0" encoding="utf-8"?>
<settings version="3.1.1">
  <id>78be924b-a4c6-40f9-ac4e-103fd8f17ce0</id>
  <name>EF Core Settings</name>
  <designerReferences />
  <packageSettings />
  <packageExtensions>
    <packageExtension type="Domain Package" typeId="1a824508-4623-45d9-accc-f572091ade5a">
      <requiredPackages />
      <contextMenuOptions />
      <creationOptions />
      <scriptOptions />
      <typeOrder />
      <macros>
        <macro trigger="on-changed">
          <script>const dbSettingsId = "ac0a788e-d8b3-4eea-b56d-538608f1ded9";
const partitionKeyStereotypeId = "3a203a3e-116e-4a7c-b375-e690570efc3f";
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";

// console.log(`Package (${element.getName()}) :: On Changed
//     isCosmosDbProvider() = ${isCosmosDbProvider()}`);

if (element.specialization !== "Domain Package") {
    return;
}

if (!isCosmosDbProvider()) {
    return;
}

lookupTypesOf("Class")?.filter(x =&gt; isAggregateRoot(x) &amp;&amp; !hasSuperClass(x)).forEach(clazz =&gt; {
    let partitionKey = getNearestCosmosDbContainerSettings(clazz)?.getProperty("Partition Key")?.value?.trim();
    if (partitionKey == "") { partitionKey = null; }

    let primaryKeyAttr = clazz.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))[0];
    if (!partitionKey &amp;&amp; primaryKeyAttr &amp;&amp; !primaryKeyAttr.hasStereotype(partitionKeyStereotypeId)) { 
        element.getChildren("Attribute").filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId)).forEach(x =&gt; x.removeStereotype(partitionKeyStereotypeId));
        primaryKeyAttr.addStereotype(partitionKeyStereotypeId);
        return;
    }

    if (!partitionKey) { return; }

    managePartitionKey(clazz, partitionKey);
});

// === FUNCTIONS ===

function managePartitionKey(clazz, partitionKey) {
    let possiblePartKeyAttrs = clazz.getChildren("Attribute")
        .filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId) || x.getName().toLowerCase() == partitionKey.toLowerCase())
    if (possiblePartKeyAttrs.length == 0) {
        let pkAttr = createElement("Attribute", partitionKey, clazz.id);
        pkAttr.setOrder(1);
        pkAttr.typeReference.setType(stringTypeId);
        // Attribute events will add Part Key stereotype
    } else if (
        possiblePartKeyAttrs.length == 1 &amp;&amp; 
        possiblePartKeyAttrs[0].hasStereotype(partitionKeyStereotypeId) &amp;&amp;
        ! possiblePartKeyAttrs[0].hasStereotype("Primary Key")
        ) {
            possiblePartKeyAttrs[0].setName(partitionKey);
    } else {
        clazz.getChildren("Attribute").filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId)).forEach(x =&gt; x.removeStereotype(partitionKeyStereotypeId));
        let possiblePartKeyAttrs = clazz.getChildren("Attribute").filter(x =&gt; x.getName().toLowerCase() == partitionKey.toLowerCase());
        if (possiblePartKeyAttrs.length == 0) {
            let pkAttr = createElement("Attribute", partitionKey, clazz.id);
            pkAttr.setOrder(1);
            pkAttr.typeReference.setType(stringTypeId);
            // Attribute events will add Part Key stereotype
        } else if (! possiblePartKeyAttrs[0].hasStereotype(partitionKeyStereotypeId)) {
            possiblePartKeyAttrs[0].addStereotype(partitionKeyStereotypeId);
        }
    }
}

function getNearestCosmosDbContainerSettings(clazz) {
    let stereotype;
    let current = clazz;
    do
    {
        stereotype = current.getStereotype("Cosmos DB Container Settings");
        if (stereotype) {
            return stereotype;
        }
        current = current.getParent();
    } while (current);

    stereotype = clazz.getPackage()?.getStereotype("Cosmos DB Container Settings");
    if (stereotype) {
        return stereotype;
    }

    return null;
}

function isCosmosDbProvider() {
    return application.getSettings(dbSettingsId)
        ?.getField("Database Provider")
        ?.value == "cosmos";
}

function hasSuperClass(element) {
    return element.getAssociations("Generalization")
        .some(x =&gt; x.isTargetEnd());
}

function isAggregateRoot(element) {
    return ! element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}

function getNamingConvention() {
    return application.getSettings(dbSettingsId)
        .getField("Key Naming Convention")?.value ?? "pascal-case";
}</script>
        </macro>
        <macro trigger="on-created">
          <script>if (element.specialization !== "Domain Package") {
    return;
}

if (!isCosmosDbProvider()) {
    return;
}

if (! element.hasStereotype("Cosmos DB Container Settings")) {
    element.addStereotype("b4995259-b47b-405a-a332-fd3dc69cd3a5");
}

function isCosmosDbProvider() {
    return application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")
        ?.getField("Database Provider")
        ?.value == "cosmos";
}</script>
        </macro>
        <macro trigger="on-loaded">
          <script>const partitionKeyStereotypeId = "3a203a3e-116e-4a7c-b375-e690570efc3f";

if (element.specialization !== "Domain Package") {
    return;
}

if (!isCosmosDbProvider()) {
    return;
}

ensureCosmosDbContainer(element);
ensureClassesHavePartitionKey();

// === FUNCTIONS ===

function managePartitionKey(clazz, partitionKey) {
    let possiblePartKeyAttrs = clazz.getChildren("Attribute")
        .filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId) || x.getName().toLowerCase() == partitionKey.toLowerCase())
    if (possiblePartKeyAttrs.length == 0) {
        let pkAttr = createElement("Attribute", partitionKey, clazz.id);
        pkAttr.setOrder(1);
        pkAttr.typeReference.setType(stringTypeId);
        // Attribute events will add Part Key stereotype
    } else if (
        possiblePartKeyAttrs.length == 1 &amp;&amp; 
        possiblePartKeyAttrs[0].hasStereotype(partitionKeyStereotypeId) &amp;&amp;
        ! possiblePartKeyAttrs[0].hasStereotype("Primary Key")
        ) {
            possiblePartKeyAttrs[0].setName(partitionKey);
    } else {
        clazz.getChildren("Attribute").filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId)).forEach(x =&gt; x.removeStereotype(partitionKeyStereotypeId));
        let possiblePartKeyAttrs = clazz.getChildren("Attribute").filter(x =&gt; x.getName().toLowerCase() == partitionKey.toLowerCase());
        if (possiblePartKeyAttrs.length == 0) {
            let pkAttr = createElement("Attribute", partitionKey, clazz.id);
            pkAttr.setOrder(1);
            pkAttr.typeReference.setType(stringTypeId);
            // Attribute events will add Part Key stereotype
        } else if (! possiblePartKeyAttrs[0].hasStereotype(partitionKeyStereotypeId)) {
            possiblePartKeyAttrs[0].addStereotype(partitionKeyStereotypeId);
        }
    }
}

function getNearestCosmosDbContainerSettings(clazz) {
    let stereotype;
    let current = clazz;
    do
    {
        stereotype = current.getStereotype("Cosmos DB Container Settings");
        if (stereotype) {
            return stereotype;
        }
        current = current.getParent();
    } while (current);

    stereotype = clazz.getPackage()?.getStereotype("Cosmos DB Container Settings");
    if (stereotype) {
        return stereotype;
    }

    return null;
}

function ensureCosmosDbContainer(element) {
    const cosmosDbContainerStereotypeId = "b4995259-b47b-405a-a332-fd3dc69cd3a5";
    if (! element.hasStereotype("Cosmos DB Container Settings")) {
        element.addStereotype(cosmosDbContainerStereotypeId);
    }
}

function ensureClassesHavePartitionKey() {
    lookupTypesOf("Class").forEach(clazz =&gt; {
        processSingleClassForPartitionKey(clazz);
    });
}

function processSingleClassForPartitionKey(clazz) {
    const partitionKeyStereotypeId = "3a203a3e-116e-4a7c-b375-e690570efc3f";
    const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";
    
    if (!isCosmosDbProvider() || (!isAggregateRoot(clazz) &amp;&amp; !clazz.hasStereotype("Table")) || hasSuperClass(clazz)) { 
        clazz.getChildren("Attribute")
            .filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId))
            .forEach(x =&gt; {
                x.removeStereotype(partitionKeyStereotypeId);
                x.delete();
            });
        return; 
    }

    let partitionKey = getNearestCosmosDbContainerSettings(clazz)?.getProperty("Partition Key")?.value?.trim();
    if (partitionKey == "") { partitionKey = null; }

    let partitionKeyAttributes = clazz.getChildren("Attribute").filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId));
    
    if (partitionKeyAttributes.length &gt; 1) {
        partitionKeyAttributes.forEach(x =&gt; x.removeStereotype(partitionKeyStereotypeId));
    }

    let primaryKeyAttr = clazz.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))[0];
    if (!partitionKey &amp;&amp; primaryKeyAttr &amp;&amp; !primaryKeyAttr.hasStereotype(partitionKeyStereotypeId)) { 
        primaryKeyAttr.addStereotype(partitionKeyStereotypeId);
        return;
    }

    if (!partitionKey) { return; }

    managePartitionKey(clazz, partitionKey);
}

function isCosmosDbProvider() {
    const dbSettingsId = "ac0a788e-d8b3-4eea-b56d-538608f1ded9";
    return application.getSettings(dbSettingsId)
        ?.getField("Database Provider")
        ?.value == "cosmos";
}

function isAggregateRoot(element) {
    return ! element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}

function hasSuperClass(element) {
    return element.getAssociations("Generalization")
        .some(x =&gt; x.isTargetEnd());
}</script>
        </macro>
      </macros>
    </packageExtension>
  </packageExtensions>
  <elementSettings />
  <elementExtensions>
    <elementExtension type="Attribute" typeId="0090fb93-483e-41af-a11d-5ad2dc796adf">
      <mappingSettings />
      <macros>
        <macro trigger="on-changed">
          <script>const dbSettingsId = "ac0a788e-d8b3-4eea-b56d-538608f1ded9";
const partitionKeyStereotypeId = "3a203a3e-116e-4a7c-b375-e690570efc3f";

// console.log(`Attribute (${element.getName()}) :: On Changed
//     isCosmosDbProvider() = ${isCosmosDbProvider()}
//     isAggregateRoot(element.getParent()) = ${isAggregateRoot(element.getParent())}
//     hasSuperClass(element.getParent()) = ${hasSuperClass(element.getParent())}`);

if (element.getPackage().specialization !== "Domain Package") {
    return;
}

if (!isCosmosDbProvider() || (!isAggregateRoot(element.getParent()) &amp;&amp; !element.getParent().hasStereotype("Table")) || hasSuperClass(element.getParent())) { 
    return; 
}

if (element.hasStereotype(partitionKeyStereotypeId) &amp;&amp; 
    element.getParent().getChildren("Attribute").some(x =&gt; x.id != element.id &amp;&amp; x.hasStereotype(partitionKeyStereotypeId))) {
        
    element.removeStereotype(partitionKeyStereotypeId);
    await dialogService.error(`The Partition Key should not be managed manually. Click on the ${element.getPackage().getName()} package to change the Partition Key name.`);
}

// === FUNCTIONS ===

function isCosmosDbProvider() {
    return application.getSettings(dbSettingsId)
        ?.getField("Database Provider")
        ?.value == "cosmos";
}

function isAggregateRoot(element) {
    return ! element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}

function hasSuperClass(element) {
    return element.getAssociations("Generalization")
        .some(x =&gt; x.isTargetEnd());
}

function getNamingConvention() {
    return application.getSettings(dbSettingsId)
        .getField("Key Naming Convention")?.value ?? "pascal-case";
}</script>
        </macro>
        <macro trigger="on-created">
          <script>const dbSettingsId = "ac0a788e-d8b3-4eea-b56d-538608f1ded9";
const partitionKeyStereotypeId = "3a203a3e-116e-4a7c-b375-e690570efc3f";

// console.log(`Attribute (${element.getName()}) :: On Created
//     isCosmosDbProvider() = ${isCosmosDbProvider()}
//     isAggregateRoot(element.getParent()) = ${isAggregateRoot(element.getParent())}
//     hasSuperClass(element.getParent()) = ${hasSuperClass(element.getParent())}`);

if (element.getPackage().specialization !== "Domain Package") {
    return;
}

if (!isCosmosDbProvider() || (!isAggregateRoot(element.getParent()) &amp;&amp; !element.getParent().hasStereotype("Table")) || hasSuperClass(element.getParent())) { 
    return; 
}

let partitionKey = getNearestCosmosDbContainerSettings(element.getParent())?.getProperty("Partition Key").value?.trim();
if (partitionKey == "") { partitionKey = null; }

if (!partitionKey &amp;&amp; element.hasStereotype("Primary Key")) { 
    element.addStereotype(partitionKeyStereotypeId);
    return;
}

if (!partitionKey) { return; }

if (element.getName() == partitionKey &amp;&amp; !element.hasStereotype(partitionKeyStereotypeId)) {
    element.addStereotype(partitionKeyStereotypeId);
}

// === FUNCTIONS ===

function getNearestCosmosDbContainerSettings(clazz) {
    let stereotype;
    let current = clazz;
    do
    {
        stereotype = current.getStereotype("Cosmos DB Container Settings");
        if (stereotype) {
            return stereotype;
        }
        current = current.getParent();
    } while (current);

    stereotype = clazz.getPackage()?.getStereotype("Cosmos DB Container Settings");
    if (stereotype) {
        return stereotype;
    }

    return null;
}

function isCosmosDbProvider() {
    return application.getSettings(dbSettingsId)
        ?.getField("Database Provider")
        ?.value == "cosmos";
}

function isAggregateRoot(element) {
    return ! element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}

function hasSuperClass(element) {
    return element.getAssociations("Generalization")
        .some(x =&gt; x.isTargetEnd());
}

function getNamingConvention() {
    return application.getSettings(dbSettingsId)
        .getField("Key Naming Convention")?.value ?? "pascal-case";
}</script>
        </macro>
      </macros>
    </elementExtension>
    <elementExtension type="Class" typeId="04e12b51-ed12-42a3-9667-a6aa81bb6d10">
      <validateFunctionOverride>/// &lt;reference path="../../typings/elementmacro.context.api.d.ts" /&gt;
function getSurrogateKeyType() {
    var _a, _b, _c;
    const commonTypes = {
        guid: "6b649125-18ea-48fd-a6ba-0bfff0d8f488",
        long: "33013006-E404-48C2-AC46-24EF5A5774FD",
        int: "fb0a362d-e9e2-40de-b6ff-5ce8167cbe74"
    };
    const javaTypes = {
        long: "e9e575eb-f8de-4ce4-9838-2d09665a752d",
        int: "b3e5cb3b-8a26-4346-810b-9789afa25a82"
    };
    const typeNameToIdMap = new Map();
    typeNameToIdMap.set("guid", commonTypes.guid);
    typeNameToIdMap.set("int", lookup(javaTypes.int) != null ? javaTypes.int : commonTypes.int);
    typeNameToIdMap.set("long", lookup(javaTypes.long) != null ? javaTypes.long : commonTypes.long);
    let typeName = (_c = (_b = (_a = application.getSettings("ac0a788e-d8b3-4eea-b56d-538608f1ded9")) === null || _a === void 0 ? void 0 : _a.getField("Key Type")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "int";
    if (typeNameToIdMap.has(typeName)) {
        return typeNameToIdMap.get(typeName);
    }
    return typeNameToIdMap.get("guid");
}
;
/// &lt;reference path="getSurrogateKeyType.ts"/&gt;
/// &lt;reference path="attributeWithMapPath.ts"/&gt;
class DomainHelper {
    static isAggregateRoot(element) {
        let result = !element.getAssociations("Association")
            .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
        return result;
    }
    static getCommandOperations(entity) {
        const queryOperationNames = ["Get", "Find", "Filter", "Query", "Is", "Must", "Can"];
        const operations = entity.getChildren("Operation").filter(operation =&gt; operation.typeReference.getType() == null ||
            !queryOperationNames.some(allowedOperationName =&gt; operation.getName().startsWith(allowedOperationName)));
        return operations;
    }
    static isComplexType(element) {
        return (element === null || element === void 0 ? void 0 : element.specialization) === "Data Contract" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Value Object" ||
            (element === null || element === void 0 ? void 0 : element.specialization) === "Class";
    }
    static isComplexTypeById(typeId) {
        let element = lookup(typeId);
        return DomainHelper.isComplexType(element);
    }
    static getOwningAggregate(entity) {
        var _a;
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let invalidAssociations = entity.getAssociations("Association").filter(x =&gt; x.typeReference.getType() == null);
        if (invalidAssociations.length &gt; 0) {
            console.warn("Invalid associations found:");
            invalidAssociations.forEach(x =&gt; {
                console.warn("Invalid associations: " + x.getName());
            });
        }
        let result = (_a = entity.getAssociations("Association")
            .filter(x =&gt; this.isAggregateRoot(x.typeReference.getType()) &amp;&amp; isOwnedBy(x) &amp;&amp;
            // Let's only target collections for now as part of the nested compositional crud support
            // as one-to-one relationships are more expensive to address and possibly not going to
            // be needed.
            x.getOtherEnd().typeReference.isCollection)[0]) === null || _a === void 0 ? void 0 : _a.typeReference.getType();
        return result;
        function isOwnedBy(association) {
            return association.isSourceEnd() &amp;&amp;
                !association.typeReference.isNullable &amp;&amp;
                !association.typeReference.isCollection;
        }
    }
    static ownerIsAggregateRoot(entity) {
        let result = DomainHelper.getOwningAggregate(entity);
        return result ? true : false;
    }
    static hasPrimaryKey(entity) {
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        return keys.length &gt; 0;
    }
    static getPrimaryKeys(entity) {
        if (!entity) {
            throw new Error("entity not specified");
        }
        let primaryKeys = DomainHelper.getPrimaryKeysMap(entity);
        return Object.values(primaryKeys);
    }
    static isUserSuppliedPrimaryKey(pk) {
        if (pk == null)
            return false;
        if (!pk.hasStereotype("Primary Key"))
            return false;
        var pkStereotype = pk.getStereotype("Primary Key");
        if (!pkStereotype.hasProperty("Data source")) {
            return false;
        }
        return pkStereotype.getProperty("Data source").value == "User supplied";
    }
    static getPrimaryKeysMap(entity) {
        let keydict = Object.create(null);
        let keys = entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
        keys.forEach(key =&gt; keydict[key.id] = {
            id: key.id,
            name: key.getName(),
            typeId: key.typeReference.typeId,
            mapPath: [key.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForPrimaryKeys(keydict, entity, []);
        return keydict;
        function traverseInheritanceHierarchyForPrimaryKeys(keydict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"));
            baseKeys.forEach(key =&gt; {
                keydict[key.id] = {
                    id: key.id,
                    name: key.getName(),
                    typeId: key.typeReference.typeId,
                    mapPath: generalizationStack.concat([key.id]),
                    isNullable: key.typeReference.isNullable,
                    isCollection: key.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForPrimaryKeys(keydict, nextEntity, generalizationStack);
        }
    }
    static getForeignKeys(entity, owningAggregate) {
        var _a;
        if (!entity) {
            throw new Error("entity not specified");
        }
        if (!owningAggregate) {
            throw new Error("nestedCompOwner not specified");
        }
        // Use the new Associated property on the FK stereotype method for FK Attribute lookup
        let foreignKeys = [];
        for (let attr of entity.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Foreign Key"))) {
            let associationId = (_a = attr.getStereotype("Foreign Key").getProperty("Association")) === null || _a === void 0 ? void 0 : _a.getValue();
            if (owningAggregate.getAssociations("Association").some(x =&gt; x.id == associationId)) {
                foreignKeys.push(attr);
            }
        }
        // Backward compatible lookup method
        if (foreignKeys.length == 0) {
            let foundFk = entity.getChildren("Attribute")
                .filter(x =&gt; x.getName().toLowerCase().indexOf(owningAggregate.getName().toLowerCase()) &gt;= 0 &amp;&amp; x.hasStereotype("Foreign Key"))[0];
            if (foundFk) {
                foreignKeys.push(foundFk);
            }
        }
        return foreignKeys.map(x =&gt; ({
            name: DomainHelper.getAttributeNameFormat(x.getName()),
            typeId: x.typeReference.typeId,
            id: x.id,
            mapPath: [x.id],
            isCollection: x.typeReference.isCollection,
            isNullable: x.typeReference.isNullable,
            element: x
        }));
    }
    /**
     * Returns true if the attribute is a foreign key on a compositional one-to-many relationship (i.e. is managed by the DB and should not be set).
     * @param attribute
     * @returns
     */
    static isManagedForeignKey(attribute) {
        var _a, _b;
        let fkAssociation = (_b = (_a = attribute.getStereotype("Foreign Key")) === null || _a === void 0 ? void 0 : _a.getProperty("Association")) === null || _b === void 0 ? void 0 : _b.getSelected();
        return fkAssociation != null &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsCollection() &amp;&amp; !fkAssociation.getOtherEnd().typeReference.getIsNullable();
    }
    static getChildrenOfType(entity, type) {
        let attrDict = Object.create(null);
        let attributes = entity.getChildren(type);
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: attr.typeReference.isNullable,
            isCollection: attr.typeReference.isCollection
        });
        return Object.values(attrDict);
    }
    static getAttributesWithMapPath(entity) {
        let attrDict = Object.create(null);
        let attributes = entity
            .getChildren("Attribute")
            .filter(x =&gt; {
            var _a;
            return !x.hasStereotype("Primary Key") &amp;&amp;
                !DomainHelper.legacyPartitionKey(x) &amp;&amp;
                (x["hasMetadata"] &amp;&amp; (!x.hasMetadata("set-by-infrastructure") || ((_a = x.getMetadata("set-by-infrastructure")) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) != "true"));
        });
        attributes.forEach(attr =&gt; attrDict[attr.id] = {
            id: attr.id,
            name: attr.getName(),
            typeId: attr.typeReference.typeId,
            mapPath: [attr.id],
            isNullable: false,
            isCollection: false
        });
        traverseInheritanceHierarchyForAttributes(attrDict, entity, []);
        return Object.values(attrDict);
        function traverseInheritanceHierarchyForAttributes(attrDict, curEntity, generalizationStack) {
            if (!curEntity) {
                return;
            }
            let generalizations = curEntity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            let nextEntity = generalization.typeReference.getType();
            let baseKeys = nextEntity.getChildren("Attribute").filter(x =&gt; !x.hasStereotype("Primary Key") &amp;&amp; !DomainHelper.legacyPartitionKey(x));
            baseKeys.forEach(attr =&gt; {
                attrDict[attr.id] = {
                    id: attr.id,
                    name: attr.getName(),
                    typeId: attr.typeReference.typeId,
                    mapPath: generalizationStack.concat([attr.id]),
                    isNullable: attr.typeReference.isNullable,
                    isCollection: attr.typeReference.isCollection
                };
            });
            traverseInheritanceHierarchyForAttributes(attrDict, nextEntity, generalizationStack);
        }
    }
    static getMandatoryAssociationsWithMapPath(entity) {
        return traverseInheritanceHierarchy(entity, [], []);
        function traverseInheritanceHierarchy(entity, results, generalizationStack) {
            entity
                .getAssociations("Association")
                .filter(x =&gt; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable &amp;&amp; x.typeReference.isNavigable &amp;&amp;
                !x.getOtherEnd().typeReference.isCollection &amp;&amp; !x.getOtherEnd().typeReference.isNullable)
                .forEach(association =&gt; {
                return results.push({
                    id: association.id,
                    name: association.getName(),
                    typeId: null,
                    mapPath: generalizationStack.concat([association.id]),
                    isNullable: false,
                    isCollection: false
                });
            });
            let generalizations = entity.getAssociations("Generalization").filter(x =&gt; x.isTargetEnd());
            if (generalizations.length == 0) {
                return results;
            }
            let generalization = generalizations[0];
            generalizationStack.push(generalization.id);
            return traverseInheritanceHierarchy(generalization.typeReference.getType(), results, generalizationStack);
        }
    }
    static getAttributeNameFormat(str) {
        let convention = DomainHelper.getDomainAttributeNamingConvention();
        switch (convention) {
            case "pascal-case":
                return toPascalCase(str);
            case "camel-case":
                return toCamelCase(str);
        }
        return str;
    }
    static getDomainAttributeNamingConvention() {
        var _a, _b, _c;
        const domainSettingsId = "c4d1e35c-7c0d-4926-afe0-18f17563ce17";
        return (_c = (_b = (_a = application.getSettings(domainSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Attribute Naming Convention")) === null || _b === void 0 ? void 0 : _b.value) !== null &amp;&amp; _c !== void 0 ? _c : "pascal-case";
    }
    static getSurrogateKeyType() {
        return getSurrogateKeyType();
    }
    // Just in case someone still uses this convention. Used to filter out those attributes when mapping
    // to domain entities that are within a Cosmos DB paradigm.
    static legacyPartitionKey(attribute) {
        return attribute.hasStereotype("Partition Key") &amp;&amp; attribute.getName() === "PartitionKey";
    }
    static requiresForeignKey(associationEnd) {
        return DomainHelper.isManyToVariantsOfOne(associationEnd) || DomainHelper.isSelfReferencingZeroToOne(associationEnd);
    }
    static isManyToVariantsOfOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.getOtherEnd().typeReference.isCollection;
    }
    static isSelfReferencingZeroToOne(associationEnd) {
        return !associationEnd.typeReference.isCollection &amp;&amp; associationEnd.typeReference.isNullable &amp;&amp;
            associationEnd.typeReference.typeId == associationEnd.getOtherEnd().typeReference.typeId;
    }
    static getOwningAggregateRecursive(entity) {
        let owners = DomainHelper.getOwnersRecursive(entity);
        if (owners.length == 0)
            return null;
        const uniqueIds = new Set(owners.map(item =&gt; item.id));
        if (uniqueIds.size !== 1) {
            throw new Error(`Entity : '${entity.getName()}' has more than 1 owner.`);
        }
        return owners[0];
    }
    static getOwnersRecursive(entity) {
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let results = entity.getAssociations("Association").filter(x =&gt; DomainHelper.isOwnedByAssociation(x));
        let result = [];
        for (let i = 0; i &lt; results.length; i++) {
            let owner = results[i].typeReference.getType();
            if (DomainHelper.isAggregateRoot(owner)) {
                result.push(owner);
            }
            else {
                result.push(...DomainHelper.getOwnersRecursive(owner));
            }
        }
        return result;
    }
    static isOwnedByAssociation(association) {
        return association.isSourceEnd() &amp;&amp;
            !association.typeReference.isNullable &amp;&amp;
            !association.typeReference.isCollection;
    }
    static getOwningAggregateKeyChain(entity) {
        if (!entity || entity.specialization != "Class") {
            return null;
        }
        let results = entity.getAssociations("Association").filter(x =&gt; DomainHelper.isOwnedByAssociation(x));
        let result = [];
        if (results.length == 0)
            return result;
        let owner = results[0].typeReference.getType();
        let pks = DomainHelper.getPrimaryKeys(owner);
        pks.forEach(pk =&gt; {
            let attribute = lookup(pk.id);
            //expectedName would typically be CountryId if you have a Agg: Country with a Pk: Id
            let expectedName = attribute.getParent().getName();
            if (!attribute.getName().startsWith(expectedName)) {
                expectedName += attribute.getName();
            }
            else {
                expectedName = attribute.getName();
            }
            result.push({ attribute: attribute, expectedName: expectedName });
        });
        if (!DomainHelper.isAggregateRoot(owner)) {
            result.unshift(...DomainHelper.getOwningAggregateKeyChain(owner));
        }
        return result;
    }
}
/// &lt;reference path="../../../typings/elementmacro.context.api.d.ts" /&gt;
/// &lt;reference path="../../common/domainHelper.ts" /&gt;
// Check composite only has 1 owner
const dbSettingsId = "ac0a788e-d8b3-4eea-b56d-538608f1ded9";
function validateDomainEntity(entity) {
    if (!entity.getPackage().hasStereotype("Relational Database")) {
        return null;
    }
    if (isCosmosDbProvider() || DomainHelper.isAggregateRoot(element)) {
        return null;
    }
    let owners = DomainHelper.getOwnersRecursive(entity);
    if (owners.length &gt; 1) {
        const uniqueIds = new Set(owners.map(item =&gt; item.id));
        if (uniqueIds.size !== 1) {
            let ownersDescription = owners.map(item =&gt; item.getName()).join(", ");
            return `Entity has multiple owners. The entity '${entity.getName()}' has multiple owners. [${ownersDescription}].
Compositional entities (black diamond) must have 1 owner. Please adjust the associations accordingly.`;
        }
    }
    return null;
}
function isCosmosDbProvider() {
    var _a, _b;
    return ((_b = (_a = application.getSettings(dbSettingsId)) === null || _a === void 0 ? void 0 : _a.getField("Database Provider")) === null || _b === void 0 ? void 0 : _b.value) == "cosmos";
}
/**
 * Used by Intent.EntityFrameworkCore
 *
 * Source code here:
 * https://github.com/IntentArchitect/Intent.Modules/blob/development/DesignerMacros/src/rdbms/composite-validation/composite-validation.ts
 */
return validateDomainEntity(element);
//validateDomainEntity(element);
</validateFunctionOverride>
      <mappingSettings />
      <macros>
        <macro trigger="on-changed">
          <script>const dbSettingsId = "ac0a788e-d8b3-4eea-b56d-538608f1ded9";
const partitionKeyStereotypeId = "3a203a3e-116e-4a7c-b375-e690570efc3f";
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";

// console.log(`Class (${element.getName()}) :: On Changed
//     isCosmosDbProvider() = ${isCosmosDbProvider()}
//     isAggregateRoot(element) = ${isAggregateRoot(element)}
//     hasSuperClass(element) = ${hasSuperClass(element)}`);

if (element.getPackage().specialization !== "Domain Package") {
    return;
}

if (!isCosmosDbProvider() || (!isAggregateRoot(element) &amp;&amp; !element.hasStereotype("Table")) || hasSuperClass(element)) { 
    element.getChildren("Attribute")
        .filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId))
        .forEach(x =&gt; {
            x.removeStereotype(partitionKeyStereotypeId);
            x.delete();
        });
    return; 
}

let partitionKey = getNearestCosmosDbContainerSettings(element)?.getProperty("Partition Key")?.value?.trim();
console.log(`partitionKey = ${partitionKey}`);
if (partitionKey == "") { partitionKey = null; }

let primaryKeyAttr = element.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))[0];
if (!partitionKey &amp;&amp; primaryKeyAttr &amp;&amp; !primaryKeyAttr.hasStereotype(partitionKeyStereotypeId)) { 
    element.getChildren("Attribute").filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId)).forEach(x =&gt; x.removeStereotype(partitionKeyStereotypeId));
    primaryKeyAttr.addStereotype(partitionKeyStereotypeId);
    return;
}

if (!partitionKey) { return; }

managePartitionKey(element, partitionKey);

// === FUNCTIONS ===

function managePartitionKey(clazz, partitionKey) {
    let possiblePartKeyAttrs = clazz.getChildren("Attribute")
        .filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId) || x.getName().toLowerCase() == partitionKey.toLowerCase())
    if (possiblePartKeyAttrs.length == 0) {
        let pkAttr = createElement("Attribute", partitionKey, clazz.id);
        pkAttr.setOrder(1);
        pkAttr.typeReference.setType(stringTypeId);
        // Attribute events will add Part Key stereotype
    } else if (
        possiblePartKeyAttrs.length == 1 &amp;&amp; 
        possiblePartKeyAttrs[0].hasStereotype(partitionKeyStereotypeId) &amp;&amp;
        ! possiblePartKeyAttrs[0].hasStereotype("Primary Key")
        ) {
            possiblePartKeyAttrs[0].setName(partitionKey);
    } else {
        clazz.getChildren("Attribute").filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId)).forEach(x =&gt; x.removeStereotype(partitionKeyStereotypeId));
        let possiblePartKeyAttrs = clazz.getChildren("Attribute").filter(x =&gt; x.getName().toLowerCase() == partitionKey.toLowerCase());
        if (possiblePartKeyAttrs.length == 0) {
            let pkAttr = createElement("Attribute", partitionKey, clazz.id);
            pkAttr.setOrder(1);
            pkAttr.typeReference.setType(stringTypeId);
            // Attribute events will add Part Key stereotype
        } else if (! possiblePartKeyAttrs[0].hasStereotype(partitionKeyStereotypeId)) {
            possiblePartKeyAttrs[0].addStereotype(partitionKeyStereotypeId);
        }
    }
}

function getNearestCosmosDbContainerSettings(clazz) {
    let stereotype;
    let current = clazz;
    do
    {
        stereotype = current.getStereotype("Cosmos DB Container Settings");
        if (stereotype) {
            return stereotype;
        }
        current = current.getParent();
    } while (current);

    stereotype = clazz.getPackage()?.getStereotype("Cosmos DB Container Settings");
    if (stereotype) {
        return stereotype;
    }

    return null;
}

function isCosmosDbProvider() {
    return application.getSettings(dbSettingsId)
        ?.getField("Database Provider")
        ?.value == "cosmos";
}

function isAggregateRoot(element) {
    return !element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}

function hasSuperClass(element) {
    return element.getAssociations("Generalization")
        .some(x =&gt; x.isTargetEnd());
}

// function getNamingConvention() {
//     return application.getSettings(dbSettingsId)
//         .getField("Key Naming Convention")?.value ?? "pascal-case";
// }</script>
        </macro>
        <macro trigger="on-created">
          <script>const dbSettingsId = "ac0a788e-d8b3-4eea-b56d-538608f1ded9";
const partitionKeyStereotypeId = "3a203a3e-116e-4a7c-b375-e690570efc3f";
const stringTypeId = "d384db9c-a279-45e1-801e-e4e8099625f2";

// console.log(`Class (${element.getName()}) :: On Created
//     isCosmosDbProvider() = ${isCosmosDbProvider()}
//     isAggregateRoot(element) = ${isAggregateRoot(element)}
//     hasSuperClass(element) = ${hasSuperClass(element)}`);

if (element.getPackage().specialization !== "Domain Package") {
    return;
}

if (!isCosmosDbProvider() || (!isAggregateRoot(element) &amp;&amp; !element.hasStereotype("Table")) || hasSuperClass(element)) { 
    element.getChildren("Attribute")
        .filter(x =&gt; x.hasStereotype(partitionKeyStereotypeId))
        .forEach(x =&gt; {
            x.removeStereotype(partitionKeyStereotypeId);
            x.delete();
        });
    return; 
}

let cosmosDbContainerSettingsStereotype = getNearestCosmosDbContainerSettings();
if (! (cosmosDbContainerSettingsStereotype?.getProperty("Partition Key"))) { return; }

let partitionKey = cosmosDbContainerSettingsStereotype.getProperty("Partition Key").value?.trim();
if (partitionKey == "") { partitionKey = null; }

let primaryKeyAttr = element.getChildren("Attribute").filter(x =&gt; x.hasStereotype("Primary Key"))[0];
if (!partitionKey &amp;&amp; primaryKeyAttr &amp;&amp; !primaryKeyAttr.hasStereotype(partitionKeyStereotypeId)) { 
    primaryKeyAttr.addStereotype(partitionKeyStereotypeId);
    return;
}

if (!partitionKey) { return; }

let possiblePkAttrs = element.getChildren("Attribute").filter(x =&gt; x.getName() == partitionKey)
if (possiblePkAttrs.length == 0) {
    let pkAttr = createElement("Attribute", partitionKey, element.id);
    pkAttr.setOrder(element.getChildren("Attribute").findIndex(x =&gt; x.hasStereotype("Primary Key")) + 1);
    pkAttr.typeReference.setType(stringTypeId);
} else if (! possiblePkAttrs[0].hasStereotype(partitionKeyStereotypeId)) {
    possiblePkAttrs[0].addStereotype(partitionKeyStereotypeId);
}

// === FUNCTIONS ===

function getNearestCosmosDbContainerSettings(clazz) {
    let stereotype;
    let current = clazz;
    do
    {
        stereotype = current.getStereotype("Cosmos DB Container Settings");
        if (stereotype) {
            return stereotype;
        }
        current = current.getParent();
    } while (current);

    stereotype = clazz.getPackage()?.getStereotype("Cosmos DB Container Settings");
    if (stereotype) {
        return stereotype;
    }

    return null;
}

function isCosmosDbProvider() {
    return application.getSettings(dbSettingsId)
        ?.getField("Database Provider")
        ?.value == "cosmos";
}

function isAggregateRoot(element) {
    return ! element.getAssociations("Association")
        .some(x =&gt; x.isSourceEnd() &amp;&amp; !x.typeReference.isCollection &amp;&amp; !x.typeReference.isNullable);
}

function hasSuperClass(element) {
    return element.getAssociations("Generalization")
        .some(x =&gt; x.isTargetEnd());
}

function getNamingConvention() {
    return application.getSettings(dbSettingsId)
        .getField("Key Naming Convention")?.value ?? "pascal-case";
}</script>
        </macro>
      </macros>
    </elementExtension>
  </elementExtensions>
  <associationSettings />
  <associationExtensions>
    <associationExtension type="Association" typeId="eaf9ed4e-0b61-4ac1-ba88-09f912c12087">
      <sourceEndExtension>
        <typeOrder />
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </sourceEndExtension>
      <targetEndExtension>
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </targetEndExtension>
    </associationExtension>
    <associationExtension type="Generalization" typeId="5de35973-3ac7-4e65-b48c-385605aec561">
      <sourceEndExtension>
        <typeOrder />
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </sourceEndExtension>
      <targetEndExtension>
        <typeReferenceExtension>
          <isRequired>true</isRequired>
          <targetTypes />
          <allowIsNavigable>inherit</allowIsNavigable>
          <allowIsNullable>inherit</allowIsNullable>
          <allowIsCollection>inherit</allowIsCollection>
        </typeReferenceExtension>
      </targetEndExtension>
    </associationExtension>
  </associationExtensions>
  <mappingSettings />
  <mappableElementPackages />
  <mappableElementPackageExtensions />
  <scripts />
</settings>